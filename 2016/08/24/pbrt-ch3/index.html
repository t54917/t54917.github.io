<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="CG,PBRT," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="在PBRT中，几何图元由公共接口实现，渲染器的其它部分只需使用这个接口，而不必关心相关形体的细节，从而隔离了PBRT的的几何部分与着色部分。几何图元的细节经过两层抽象，最终被完全隐藏。其一，Shape类提供了对几何图元基本信息的访问途径，如表面积、包围盒、光线交点；其二，Primitive类提供了额外的非几何信息，比如材质特性。渲染器的其它部分只与Primitive的接口交互。本章主要介绍Shap">
<meta property="og:type" content="article">
<meta property="og:title" content="PBRT 章节3 形体">
<meta property="og:url" content="http://sulpures.me/2016/08/24/pbrt-ch3/index.html">
<meta property="og:site_name" content="糖与玻璃渣">
<meta property="og:description" content="在PBRT中，几何图元由公共接口实现，渲染器的其它部分只需使用这个接口，而不必关心相关形体的细节，从而隔离了PBRT的的几何部分与着色部分。几何图元的细节经过两层抽象，最终被完全隐藏。其一，Shape类提供了对几何图元基本信息的访问途径，如表面积、包围盒、光线交点；其二，Primitive类提供了额外的非几何信息，比如材质特性。渲染器的其它部分只与Primitive的接口交互。本章主要介绍Shap">
<meta property="og:updated_time" content="2016-08-24T06:07:05.432Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PBRT 章节3 形体">
<meta name="twitter:description" content="在PBRT中，几何图元由公共接口实现，渲染器的其它部分只需使用这个接口，而不必关心相关形体的细节，从而隔离了PBRT的的几何部分与着色部分。几何图元的细节经过两层抽象，最终被完全隐藏。其一，Shape类提供了对几何图元基本信息的访问途径，如表面积、包围盒、光线交点；其二，Primitive类提供了额外的非几何信息，比如材质特性。渲染器的其它部分只与Primitive的接口交互。本章主要介绍Shap">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://sulpures.me/2016/08/24/pbrt-ch3/"/>

  <title> PBRT 章节3 形体 | 糖与玻璃渣 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">糖与玻璃渣</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                PBRT 章节3 形体
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-24T12:47:34+08:00" content="2016-08-24">
              2016-08-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Graphics/" itemprop="url" rel="index">
                    <span itemprop="name">Graphics</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在PBRT中，几何图元由公共接口实现，渲染器的其它部分只需使用这个接口，而不必关心相关形体的细节，从而隔离了PBRT的的几何部分与着色部分。几何图元的细节经过两层抽象，最终被完全隐藏。其一，Shape类提供了对几何图元基本信息的访问途径，如表面积、包围盒、光线交点；其二，Primitive类提供了额外的非几何信息，比如材质特性。渲染器的其它部分只与Primitive的接口交互。<br>本章主要介绍Shape类，其收录于core/shape.h与core/shape.cpp。Primitive类详见章节4。</p>
<h2 id="3-1-基本形体接口-P136"><a href="#3-1-基本形体接口-P136" class="headerlink" title="3.1 基本形体接口 P136"></a>3.1 基本形体接口 P136</h2><p>Shape使用了引用计数法：PBRT记录了对形体的引用计数，计数归零时该形体会被自动删除。尽管不能做到绝对安全，但也是一种有效的垃圾回收方式。ReferenceCounted类收录了其潜在机制，引用对形体对象进行记录，必须继承此类。详见附录A.5.2。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Shape Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> Shape : <span class="keyword">public</span> ReferenceCounted</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;Shape Interface <span class="number">109</span>&gt;</div><div class="line">        &lt;Shape Public Data <span class="number">108</span>&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>形体的坐标定义在对象坐标空间下，因此需要移植到世界坐标空间下。构造函数提供了此过程及其逆过程。此外，提供布尔值用于判断是否反转法线方向。这个对形体的命运有很大的关系：法线方向决定形体的内外，特别是发光体，法线所指的一侧发光。构造函数中存储了O2W转换中Transform::SwapsHandedness()的结果，这个结果值将在每次找到光线交点时，在DifferentialGeometry类的构造函数中被使用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Shape Method Definitions&gt; ≡</div><div class="line">    Shape::Shape(<span class="keyword">const</span> Transform *o2w, <span class="keyword">const</span> Transform *w2o, <span class="keyword">bool</span> ro)</div><div class="line">        : ObjectToWorld(o2w), WorldToObject(w2o), ReverseOrientation(ro),</div><div class="line">    TransformSwapsHandedness(o2w-&gt;SwapsHandedness()),</div><div class="line">    shapeId(nextshapeId++) &#123; &#125;</div></pre></td></tr></table></figure></p>
<p>一个细节，形体类中存储了指向变换的指针，而不是Transform类本身。此外系统中所有形体拥有uint32_t定义的标识ID。ID始于1，0用于表示无形体。</p>
<h3 id="3-1-1-边界"><a href="#3-1-1-边界" class="headerlink" title="3.1.1 边界"></a>3.1.1 边界</h3><p>每个形体都需要计算其包围盒。ObjectBound()用于计算对象空间下的BBox，WorldBound()将其映射到世界空间下。但，若O2W常使形体的分布更加的紧密、规律，此时应该重写后者。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Shape Method Definitions&gt; +≡</div><div class="line">    BBox Shape::WorldBound() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> (*ObjectToWorld)(ObjectBound());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-1-2-细化"><a href="#3-1-2-细化" class="headerlink" title="3.1.2 细化"></a>3.1.2 细化</h3><p>并不是所有的形体都有能力求和光线的交点。例如，某一平面需要细分为三角形之后才能计算交点；另一种可能，有些形体只是储存于硬盘中的大量几何体的占位符，当光线击中形体的包围盒后，再将几何体读入内存详细讨论，因此形体本身不具备求交能力。Shape::CanIntersect()返回判断的布尔值，其缺省如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Shape Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">bool</span> Shape::CanIntersect() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果形体不可被直接求交，必须重载其细分函数Shape::Refine()。此外，保证CanIntersect()返回true时不调用Refine()。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Shape Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">void</span> Shape::Refine(<span class="built_in">vector</span>&lt;Reference&lt;Shape&gt; &gt; &amp;refined) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        Severe(<span class="string">"Unimplemented Shape::Refine() method called"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-1-3-交点"><a href="#3-1-3-交点" class="headerlink" title="3.1.3 交点"></a>3.1.3 交点</h3><p>求交有两个函数，Intersect()和IntersectP()。前文已述。当读写这两个函数时，要满足以下基本法。</p>
<ul>
<li>满足区间[Ray::mint，Ray::maxt]</li>
<li>最近交点存于指针tHit中</li>
<li>交点信息存于DifferentialGeometry中</li>
<li>传进的光是在世界空间下的，而求交测试要在对象空间下完成，而返回的微分几何信息又必须定义在世界空间下</li>
<li>自相交问题，详见下</li>
</ul>
<p>Shape类中只提供了求交的缺省，返回一句错误信息。CanIntersect()返回真的子类必须提供该函数的具体实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;Shape Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">bool</span> Shape::Intersect(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">float</span> *tHit, <span class="keyword">float</span> *rayEpsilon,</div><div class="line">    DifferentialGeometry *dg) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        Severe(<span class="string">"Unimplemented Shape::Intersect() method called"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Shape Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">bool</span> Shape::IntersectP(<span class="keyword">const</span> Ray &amp;ray) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        Severe(<span class="string">"Unimplemented Shape::IntersectP() method called"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-1-4-自相交的避免"><a href="#3-1-4-自相交的避免" class="headerlink" title="3.1.4 自相交的避免"></a>3.1.4 自相交的避免</h3><p>由于有限的浮点精度和舍入误差，当计算某光面交点时，计算出的位置可能比真实的位置略上或略下。而以计算出的位置为起始位置计算反射光或是阴影光线时，下一个交点又落到了同一面上。<br>PBRT的解决方式是将Intersection()中的Ray::mint设置为一个极小的Epsilon值。该值足够大时，能够筛选掉自相交的情况。<del>本垃圾不确定这一段是否理解的正确</del></p>
<h3 id="3-1-5-几何着色"><a href="#3-1-5-几何着色" class="headerlink" title="3.1.5 几何着色"></a>3.1.5 几何着色</h3><p>一些形体，有其是三角网格中的形体，表面上的点可能有两种微分几何信息。其一，真实的的几何信息，精确反映了面的局部信息；其二，着色几何信息，拥有和前者不同的法向量和切向量。在三角网格中，使用后者进行插值的结果可能更加平滑。<br>Shape::GetShadingGeometry()函数实现此功能。缺省状态下，着色几何信息等于真实几何信息。需要补充的是，函数本身传入了O2W的变换，如果需要O2W，必须使用此参数完成而非Shape::ObjectToWorld。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Shape Interface&gt; +≡ <span class="number">108</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetShadingGeometry</span><span class="params">(<span class="keyword">const</span> Transform &amp;obj2world,</span></span></div><div class="line">                                    <span class="keyword">const</span> DifferentialGeometry &amp;dg,</div><div class="line">    DifferentialGeometry *dgShading) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        *dgShading = dg;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-1-6-表面面积"><a href="#3-1-6-表面面积" class="headerlink" title="3.1.6 表面面积"></a>3.1.6 表面面积</h3><p>有些场合需要在对象空间内计算表面积（如区域光）。注，只有可求交的形体才会调用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Shape Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">float</span> Shape::Area() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        Severe(<span class="string">"Unimplemented Shape::Area() method called"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0.</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-1-7-片面性"><a href="#3-1-7-片面性" class="headerlink" title="3.1.7 片面性"></a>3.1.7 片面性</h3><p>许多渲染系统，特别是使用了扫描线或Z-Buffer的，都支持单面（One-Sided）形体的概念——形体在正面可见，在反面则不可见。特别的，当几何体是封闭的且观察点总是在它的外面时，剔除几何体的背面部分不会影响最后的渲染结果。这个优化可以加快这类隐藏面消除算法的速度。但这个思路在光线追踪中并无用处，因为这里是先求光物交点，再进行背面测试(Back-Facing Test)。此外，若单面物体不是封闭的，这种技巧可能导致物理上的场景不一致：例如，当追踪一条从光源到一个表面上点的阴影光线时，另一个表面B可能中途遮挡，而在另一个方向追踪阴影光线时，B可能不会遮挡。因此，PBRT不支持这个特性。</p>
<h2 id="3-2-球面-P142"><a href="#3-2-球面-P142" class="headerlink" title="3.2 球面 P142"></a>3.2 球面 P142</h2><p>球面，特殊的二次曲面（Quadrics）。PBRT支持的二次曲面有：球面，圆锥面，圆盘（一种特殊的圆锥面），圆柱面，双曲面和抛物面。本节代码详见shapes/sphere.h和shapes/sphere.cpp。<br>下面是中学数学的时间。许多曲面可使用参数方程的方式将2D的坐标映射到3D面上的点。球的参数方程：<br>$$x=r\sin\theta \cos\phi\<br>y=r\sin\theta \sin\phi\<br>z=r\cos\theta$$<br>通过以下变换将f (θ，φ)映射到[0，1]X[0，1]区间的函数f (u，v)中。后者对纹理映射更加的友好。<br>$$\phi=u\phi<em>{max}\<br>\theta=\theta</em>{min}+v(\theta<em>{max}-\theta</em>{min})<br>$$</p>
<h3 id="3-2-1-构造"><a href="#3-2-1-构造" class="headerlink" title="3.2.1 构造"></a>3.2.1 构造</h3><p>Sphere类在对象空间中定义了中心在原点的球面。为将球面放置到世界坐标下，需提供变换。球的半径可为任意的正值，此外需提供Z值的范围以及角度φ的极值：位于[zmin，zmax]外的部分、超出[0，φmax]的部分将被截去。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;Sphere Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> Sphere : <span class="keyword">public</span> Shape</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;Sphere Public Methods&gt;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        &lt;Sphere Private Data <span class="number">116</span>&gt;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&lt;Sphere Method Definitions&gt; ≡</div><div class="line">    Sphere::Sphere(<span class="keyword">const</span> Transform *o2w, <span class="keyword">const</span> Transform *w2o, <span class="keyword">bool</span> ro,</div><div class="line">                   <span class="keyword">float</span> rad, <span class="keyword">float</span> z0, <span class="keyword">float</span> z1, <span class="keyword">float</span> pm)</div><div class="line">        : Shape(o2w, w2o, ro)</div><div class="line">    &#123;</div><div class="line">        radius = rad;</div><div class="line">        zmin = Clamp(min(z0, z1), -radius, radius);</div><div class="line">        zmax = Clamp(max(z0, z1), -radius, radius);</div><div class="line">        thetaMin = acosf(Clamp(zmin/radius, <span class="number">-1.</span>f, <span class="number">1.f</span>));</div><div class="line">        thetaMax = acosf(Clamp(zmax/radius, <span class="number">-1.</span>f, <span class="number">1.f</span>));</div><div class="line">        phiMax = Radians(Clamp(pm, <span class="number">0.0f</span>, <span class="number">360.0f</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Sphere Private Data&gt; ≡ <span class="number">115</span></div><div class="line">    <span class="keyword">float</span> radius;</div><div class="line">    <span class="keyword">float</span> phiMax;</div><div class="line">    <span class="keyword">float</span> zmin, zmax;</div><div class="line">    <span class="keyword">float</span> thetaMin, thetaMax;</div></pre></td></tr></table></figure></p>
<h3 id="3-2-2-边界"><a href="#3-2-2-边界" class="headerlink" title="3.2.2 边界"></a>3.2.2 边界</h3><p>球的包围盒很容易得出。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Sphere Method Definitions&gt; +≡</div><div class="line">    BBox Sphere::ObjectBound() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> BBox(Point(-radius, -radius, zmin),</div><div class="line">        Point( radius, radius, zmax));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-2-3-交点"><a href="#3-2-3-交点" class="headerlink" title="3.2.3 交点"></a>3.2.3 交点</h3><p>当圆心是原点时，计算最为简单。因此，求交前需进行W2O变换。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;Sphere Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">bool</span> Sphere::Intersect(<span class="keyword">const</span> Ray &amp;r, <span class="keyword">float</span> *tHit, <span class="keyword">float</span> *rayEpsilon,</div><div class="line">    DifferentialGeometry *dg) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">float</span> phi;</div><div class="line">        Point phit;</div><div class="line">        &lt;Transform Ray to object space <span class="number">117</span>&gt;</div><div class="line">        &lt;Compute quadratic sphere coefficients <span class="number">118</span>&gt;</div><div class="line">        &lt;Solve quadratic equation <span class="keyword">for</span> t values <span class="number">118</span>&gt;</div><div class="line">        &lt;Compute sphere hit position and φ <span class="number">119</span>&gt;</div><div class="line">        &lt;Test sphere intersection against clipping parameters <span class="number">120</span>&gt;</div><div class="line">        &lt;Find parametric representation of sphere hit <span class="number">120</span>&gt;</div><div class="line">        &lt;Initialize DifferentialGeometry from parametric information <span class="number">122</span>&gt;</div><div class="line">        &lt;Update tHit <span class="keyword">for</span> quadric intersection <span class="number">123</span>&gt;</div><div class="line">        &lt;Compute rayEpsilon <span class="keyword">for</span> quadric intersection <span class="number">123</span>&gt;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先，坐标转换。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Transform Ray to object space&gt; ≡ <span class="number">117</span>, <span class="number">123</span>, <span class="number">127</span>, <span class="number">131</span></div><div class="line">    Ray ray;</div><div class="line">    (*WorldToObject)(r, &amp;ray);</div></pre></td></tr></table></figure></p>
<p>将光线的参数方程代入圆的方程，得到关于t的二元一次方程。<br>$$At^2+Bt+C=0\<br>A=d_x^2+d_y^2+d_z^2\<br>B=2(d_xo_x+d_yo_y+d_zo_z)\<br>C=o_x^2+o_y^2+o_z^2-r^2<br>$$<br>直接照搬。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Compute quadratic sphere coefficients&gt; ≡ <span class="number">117</span>, <span class="number">123</span></div><div class="line">    <span class="keyword">float</span> A = ray.d.x*ray.d.x + ray.d.y*ray.d.y + ray.d.z*ray.d.z;</div><div class="line">    <span class="keyword">float</span> B = <span class="number">2</span> * (ray.d.x*ray.o.x + ray.d.y*ray.o.y + ray.d.z*ray.o.z);</div><div class="line">    <span class="keyword">float</span> C = ray.o.x*ray.o.x + ray.o.y*ray.o.y +</div><div class="line">    ray.o.z*ray.o.z - radius*radius;</div></pre></td></tr></table></figure></p>
<p>方程最多两个解。Quadratic()用于求解并赋值到t0，t1。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;Solve quadratic equation <span class="keyword">for</span> t values&gt; ≡ <span class="number">117</span>, <span class="number">123</span>, <span class="number">127</span></div><div class="line">    <span class="keyword">float</span> t0, t1;</div><div class="line">    <span class="keyword">if</span> (!Quadratic(A, B, C, &amp;t0, &amp;t1))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    &lt;Compute intersection distance along ray <span class="number">119</span>&gt;</div><div class="line"></div><div class="line">&lt;Global Inline Functions&gt; ≡</div><div class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Quadratic</span><span class="params">(<span class="keyword">float</span> A, <span class="keyword">float</span> B, <span class="keyword">float</span> C, <span class="keyword">float</span> *t0, <span class="keyword">float</span> *t1)</span></span></div><div class="line">    &#123;</div><div class="line">        &lt;Find quadratic discriminant <span class="number">118</span>&gt;</div><div class="line">        &lt;Compute quadratic t values <span class="number">119</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对于Quadratic()，首先判别式。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Find quadratic discriminant&gt; ≡ <span class="number">118</span></div><div class="line">    <span class="keyword">float</span> discrim = B * B - <span class="number">4.f</span> * A * C;</div><div class="line">    <span class="keyword">if</span> (discrim &lt;= <span class="number">0.</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">float</span> rootDiscrim = sqrtf(discrim);</div></pre></td></tr></table></figure></p>
<p>当B近似于±sqrt(B*B – 4AC)时，会导致消去错误(Cancellation Error)，影响数值精度。因此使用下述更稳定的计算方法。<br>$$t_0=\frac{q}{A}\quad t_1=\frac{C}{q}\<br>B<0,\quad q="-0.5(B-\sqrt\Delta)\\" b\geq0,\quad="" 因此：="" <figure="" class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;Compute quadratic t values&gt; ≡ <span class="number">118</span></div><div class="line">    <span class="keyword">float</span> q;</div><div class="line">    <span class="keyword">if</span> (B &lt; <span class="number">0</span>) </div><div class="line">    &#123;</div><div class="line">        q = <span class="number">-.5</span>f * (B - rootDiscrim);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        q = <span class="number">-.5</span>f * (B + rootDiscrim);</div><div class="line">    &#125;</div><div class="line">    *t0 = q / A;</div><div class="line">    *t1 = C / q;</div><div class="line">    <span class="keyword">if</span> (*t0 &gt; *t1)</div><div class="line">    &#123;</div><div class="line">        swap(*t0, *t1);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div></pre></td></tr></table></0,\quad></p>
<p>最后，判断交点与光线区间的关系。将满足条件的交点储存于thit。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;Compute intersection distance along ray&gt; ≡ <span class="number">118</span></div><div class="line">    <span class="keyword">if</span> (t0 &gt; ray.maxt || t1 &lt; ray.mint)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">float</span> thit = t0;</div><div class="line">    <span class="keyword">if</span> (t0 &lt; ray.mint)</div><div class="line">    &#123;</div><div class="line">        thit = t1;</div><div class="line">        <span class="keyword">if</span> (thit &gt; ray.maxt)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-2-4-局部球面"><a href="#3-2-4-局部球面" class="headerlink" title="3.2.4 局部球面"></a>3.2.4 局部球面</h3><p>使用的球面是经z和φ裁剪过的球面。交点位于未被裁剪的部分时才是有效的。显然φ=arctan(y/x)，由于标准库函数atan2f返回值的范围是[-π，π]，因此把结果值转换到0和2π之间。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;Compute sphere hit position and φ&gt; ≡ <span class="number">117</span>, <span class="number">120</span>, <span class="number">123</span></div><div class="line">    phit = ray(thit);</div><div class="line">    <span class="keyword">if</span> (phit.x == <span class="number">0.f</span> &amp;&amp; phit.y == <span class="number">0.f</span>)</div><div class="line">    &#123;</div><div class="line">        phit.x = <span class="number">1e-5</span>f * radius;</div><div class="line">    &#125;</div><div class="line">    phi = atan2f(phit.y, phit.x);</div><div class="line">    <span class="keyword">if</span> (phi &lt; <span class="number">0.</span>)</div><div class="line">    &#123;</div><div class="line">        phi += <span class="number">2.f</span>*M_PI;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>现在，使用z和φ测试t0和t1的有效性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;Test sphere intersection against clipping parameters&gt; ≡ 117, 123</div><div class="line">if ((zmin &gt; -radius &amp;&amp; phit.z &lt; zmin) ||</div><div class="line">    (zmax &lt; radius &amp;&amp; phit.z &gt; zmax) || phi &gt; phiMax)</div><div class="line">    &#123;</div><div class="line">        if (thit == t1)</div><div class="line">        &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        if (t1 &gt; ray.maxt)</div><div class="line">        &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        thit = t1;</div><div class="line">        &lt;Compute sphere hit position and φ 119&gt;</div><div class="line">        if ((zmin &gt; -radius &amp;&amp; phit.z &lt; zmin) ||</div><div class="line">            (zmax &lt; radius &amp;&amp; phit.z &gt; zmax) || phi &gt; phiMax)</div><div class="line">        &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>到了这一步，可以确定光线击中了球面的某点。接下来，为Differential<br>Geometry提供数据。首先根据上文映射到f（u，v），之后求得位置偏导数与法线偏导数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Find parametric representation of sphere hit&gt; ≡ <span class="number">117</span></div><div class="line">    <span class="keyword">float</span> u = phi / phiMax;</div><div class="line">    <span class="keyword">float</span> theta = acosf(Clamp(phit.z / radius, <span class="number">-1.</span>f, <span class="number">1.f</span>));</div><div class="line">    <span class="keyword">float</span> v = (theta - thetaMin) / (thetaMax - thetaMin);</div><div class="line">    &lt;Compute sphere ∂p/∂u and ∂p/∂v <span class="number">121</span>&gt;</div><div class="line">    &lt;Compute sphere ∂n/∂u and ∂n/∂v <span class="number">122</span>&gt;</div></pre></td></tr></table></figure></p>
<p>$$x=r\sin\theta \cos\phi\<br>\frac{\partial p<em>x}{\partial u}=\frac{\partial}{\partial u}(r\sin\theta \cos\phi)\<br>=r\sin\theta\frac{\partial}{\partial u}(\cos\phi)\<br>=r\sin\theta(-\phi</em>{max}\sin\phi)\<br>=-\phi_{max}y<br>$$<br>同理：<br>$$\frac{\partial p<em>y}{\partial u}=\phi</em>{max}x \quad \frac{\partial p<em>z}{\partial u}=0$$<br>以上，可得∂p/∂u；同理，可得∂p/∂v。<br>$$\frac{\partial p}{\partial u}=(-\phi</em>{max}y,\phi<em>{max}x,0)\<br>\frac{\partial p}{\partial v}(\theta</em>{max}-\theta_{min})(z\cos\phi,z\sin\phi,-r\sin\theta)$$<br>结果写入函数中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;Compute sphere ∂p/∂u and ∂p/∂v&gt; ≡ <span class="number">120</span></div><div class="line">    <span class="keyword">float</span> zradius = sqrtf(phit.x*phit.x + phit.y*phit.y);</div><div class="line">    <span class="keyword">float</span> invzradius = <span class="number">1.f</span> / zradius;</div><div class="line">    <span class="keyword">float</span> cosphi = phit.x * invzradius;</div><div class="line">    <span class="keyword">float</span> sinphi = phit.y * invzradius;</div><div class="line">    <span class="function">Vector <span class="title">dpdu</span><span class="params">(-phiMax * phit.y, phiMax * phit.x, <span class="number">0</span>)</span></span>;</div><div class="line">    Vector dpdv = (thetaMax-thetaMin) *</div><div class="line">    Vector(phit.z * cosphi, phit.z * sinphi,</div><div class="line">    -radius * sinf(theta));</div></pre></td></tr></table></figure></p>
<h3 id="3-2-5-法线偏导数"><a href="#3-2-5-法线偏导数" class="headerlink" title="3.2.5 法线偏导数"></a>3.2.5 法线偏导数</h3><p>法线的偏导数由微分几何学中的外恩加滕方程（Weingarten Equations）给出。<br>$$\frac{\partial n}{\partial u}=\frac{fF-eG}{EG-F^2}\frac{\partial p}{\partial u}+\frac{eF-fE}{EG-F^2}\frac{\partial p}{\partial v}\<br>\frac{\partial n}{\partial v}=\frac{gF-fG}{EG-F^2}\frac{\partial p}{\partial u}+\frac{fF-gE}{EG-F^2}\frac{\partial p}{\partial v}$$<br>其中，其中E， F和G是第一基本型的系数，如下。<br>$$E=|\frac{\partial p}{\partial u}|^2 \quad F=(\frac{\partial p}{\partial u}\frac{\partial p}{\partial v}) \quad G=|\frac{\partial p}{\partial v}|^2$$<br>e，f和g是第二基本型系数，如下。<br>$$e=(n\frac{\partial^2p}{\partial u^2})=n[-\phi^2<em>{max}(x,y,0)]\<br>f=(n\frac{\partial^2p}{\partial u\partial v})=n[(\theta</em>{max}-\theta<em>{min})z\phi</em>{max}(-\sin\phi,\cos\phi,0)]\<br>g=(n\frac{\partial^2p}{\partial v^2})=n[-(\theta<em>{max}-\theta</em>{min})^2(x,y,z)]$$<br><del>我整个人都不好了</del><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;Compute sphere ∂n/∂u and ∂n/∂v&gt; ≡ <span class="number">120</span></div><div class="line">    Vector d2Pduu = -phiMax * phiMax * Vector(phit.x, phit.y, <span class="number">0</span>);</div><div class="line">    Vector d2Pduv = (thetaMax - thetaMin) * phit.z * phiMax *</div><div class="line">    Vector(-sinphi, cosphi, <span class="number">0.</span>);</div><div class="line">    Vector d2Pdvv = -(thetaMax - thetaMin) * (thetaMax - thetaMin) *</div><div class="line">    Vector(phit.x, phit.y, phit.z);</div><div class="line">    &lt;Compute coefficients <span class="keyword">for</span> fundamental forms <span class="number">122</span>&gt;</div><div class="line">    &lt;Compute ∂n/∂u and ∂n/∂v from fundamental form coefficients <span class="number">122</span>&gt;</div><div class="line"></div><div class="line">&lt;Compute coefficients <span class="keyword">for</span> fundamental forms&gt; ≡ <span class="number">122</span>, <span class="number">128</span></div><div class="line">    <span class="keyword">float</span> E = Dot(dpdu, dpdu);</div><div class="line">    <span class="keyword">float</span> F = Dot(dpdu, dpdv);</div><div class="line">    <span class="keyword">float</span> G = Dot(dpdv, dpdv);</div><div class="line">    Vector N = Normalize(Cross(dpdu, dpdv));</div><div class="line">    <span class="keyword">float</span> e = Dot(N, d2Pduu);</div><div class="line">    <span class="keyword">float</span> f = Dot(N, d2Pduv);</div><div class="line">    <span class="keyword">float</span> g = Dot(N, d2Pdvv);</div><div class="line"></div><div class="line">&lt;Compute ∂n/∂u and ∂n/∂v from fundamental form coefficients&gt; ≡ <span class="number">122</span>, <span class="number">128</span></div><div class="line">    <span class="keyword">float</span> invEGF2 = <span class="number">1.f</span> / (E*G - F*F);</div><div class="line">    Normal dndu = Normal((f*F - e*G) * invEGF2 * dpdu +</div><div class="line">                         (e*F - f*E) * invEGF2 * dpdv);</div><div class="line">    Normal dndv = Normal((g*F - f*G) * invEGF2 * dpdu +</div><div class="line">                         (f*F - g*E) * invEGF2 * dpdv);</div></pre></td></tr></table></figure></p>
<h3 id="3-2-6-微分几何初始化"><a href="#3-2-6-微分几何初始化" class="headerlink" title="3.2.6 微分几何初始化"></a>3.2.6 微分几何初始化</h3><p>好的，现在假设我已经理解了什么外恩加滕方程，现在对DifferentialGeometry进行初始化操作。别忘了，之前我们有过W2O操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Initialize DifferentialGeometry from parametric information&gt; ≡ <span class="number">117</span>, <span class="number">127</span>, <span class="number">131</span></div><div class="line">    <span class="keyword">const</span> Transform &amp;o2w = *ObjectToWorld;</div><div class="line">    *dg = DifferentialGeometry(o2w(phit), o2w(dpdu), o2w(dpdv),</div><div class="line">                               o2w(dndu), o2w(dndv), u, v, <span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<p>参数tHit被参数thit赋值。很自然的问题：坐标系的变换会不会对距离参数t产生影响。然，对象空间中的交点参数距离跟光线在世界空间求到的交点的参数距离完全相同，但前提条件是光线在变换过程中不被正规化。因此，不要对变换后对象空间中的光线进行正规化。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Update tHit <span class="keyword">for</span> quadric intersection&gt; ≡ <span class="number">117</span>, <span class="number">127</span>, <span class="number">131</span></div><div class="line">    *tHit = thit;</div></pre></td></tr></table></figure></p>
<p>为二次曲面设置rayEpsilon防止自相交。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Compute rayEpsilon <span class="keyword">for</span> quadric intersection&gt; ≡ <span class="number">117</span>, <span class="number">127</span>, <span class="number">131</span></div><div class="line">    *rayEpsilon = <span class="number">5e-4</span>f * *tHit;</div></pre></td></tr></table></figure></p>
<p>InteractP()与Intersect()几乎相同，但不需要微分几何部分。不再赘述。</p>
<h3 id="3-2-7-表面积"><a href="#3-2-7-表面积" class="headerlink" title="3.2.7 表面积"></a>3.2.7 表面积</h3><p>回忆：函数y = f（x）从y = a到y = b，绕x轴旋转所成曲面面积公式如下。<br>$$2\pi \int<em>a^bf(x)\sqrt{1+(f’(x))^2}dx$$<br>所以，如下。结果十分简洁。<br>$$S=\phi</em>{max}\int<em>{z</em>{min}}^{z<em>{max}}\sqrt{r^2-x^2}\sqrt{1+\frac{x^2}{r^2-x^2}}dx\<br>=\phi</em>{max}r(z<em>{max}-z</em>{min})$$<br>最后，扔进代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Sphere Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">float</span> Sphere::Area() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> phiMax * radius * (zmax-zmin);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-3-柱面-P153"><a href="#3-3-柱面-P153" class="headerlink" title="3.3 柱面 P153"></a>3.3 柱面 P153</h2><p>同样的，继承自Shape。详见shapes/cylinder.h和shapes/cylinder.cpp。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Cylinder Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> Cylinder : <span class="keyword">public</span> Shape</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;Cylinder Public Methods&gt;</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">        &lt;Cylinder Private Data <span class="number">126</span>&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<h3 id="3-3-1-构造"><a href="#3-3-1-构造" class="headerlink" title="3.3.1 构造"></a>3.3.1 构造</h3><p>给定半径r，z轴范围和φ的最大值即可确定柱面。<br>$$\phi=u\phi<em>{max}\<br>x=r\cos\phi\<br>y=r\sin\phi\<br>z=z</em>{min}+v(z<em>{max}-z</em>{min})$$<br>构造函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;Cylinder Method Definitions&gt; ≡</div><div class="line">    Cylinder::Cylinder(<span class="keyword">const</span> Transform *o2w, <span class="keyword">const</span> Transform *w2o, <span class="keyword">bool</span> ro,</div><div class="line">                       <span class="keyword">float</span> rad, <span class="keyword">float</span> z0, <span class="keyword">float</span> z1, <span class="keyword">float</span> pm)</div><div class="line">        : Shape(o2w, w2o, ro)</div><div class="line">    &#123;</div><div class="line">        radius = rad;</div><div class="line">        zmin = min(z0, z1);</div><div class="line">        zmax = max(z0, z1);</div><div class="line">        phiMax = Radians(Clamp(pm, <span class="number">0.0f</span>, <span class="number">360.0f</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Cylinder Private Data&gt; ≡ <span class="number">124</span></div><div class="line">    <span class="keyword">float</span> radius, zmin, zmax, phiMax;</div></pre></td></tr></table></figure></p>
<h3 id="3-3-2-边界"><a href="#3-3-2-边界" class="headerlink" title="3.3.2 边界"></a>3.3.2 边界</h3><p>和球面类似，缺省的包围盒的算法只考虑了z值范围而没有考虑φ的最值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Cylinder Method Definitions&gt; +≡</div><div class="line">    BBox Cylinder::ObjectBound() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        Point p1 = Point(-radius, -radius, zmin);</div><div class="line">        Point p2 = Point( radius, radius, zmax);</div><div class="line">        <span class="keyword">return</span> BBox(p1, p2);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-3-3-交点"><a href="#3-3-3-交点" class="headerlink" title="3.3.3 交点"></a>3.3.3 交点</h3><p>计算流程同球面。光线参数方程代入圆柱方程，解二元一次方程的根。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Compute quadratic cylinder coefficients&gt; ≡ <span class="number">127</span></div><div class="line">    <span class="keyword">float</span> A = ray.d.x*ray.d.x + ray.d.y*ray.d.y;</div><div class="line">    <span class="keyword">float</span> B = <span class="number">2</span> * (ray.d.x*ray.o.x + ray.d.y*ray.o.y);</div><div class="line">    <span class="keyword">float</span> C = ray.o.x*ray.o.x + ray.o.y*ray.o.y - radius*radius;</div></pre></td></tr></table></figure></p>
<p>对于所有二次曲面的形体而言，求解二次方程的过程是相似的。下述的许多片段函数将被重用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;Cylinder Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">bool</span> Cylinder::Intersect(<span class="keyword">const</span> Ray &amp;r, <span class="keyword">float</span> *tHit, <span class="keyword">float</span> *rayEpsilon,</div><div class="line">                             DifferentialGeometry *dg) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">float</span> phi;</div><div class="line">        Point phit;</div><div class="line">        &lt;Transform Ray to object space <span class="number">117</span>&gt;</div><div class="line">        &lt;Compute quadratic cylinder coefficients <span class="number">127</span>&gt;</div><div class="line">        &lt;Solve quadratic equation <span class="keyword">for</span> t values <span class="number">118</span>&gt;</div><div class="line">        &lt;Compute cylinder hit point and φ <span class="number">127</span>&gt;</div><div class="line">        &lt;Test cylinder intersection against clipping parameters <span class="number">128</span>&gt;</div><div class="line">        &lt;Find parametric representation of cylinder hit <span class="number">128</span>&gt;</div><div class="line">        &lt;Initialize DifferentialGeometry from parametric information <span class="number">122</span>&gt;</div><div class="line">        &lt;Update tHit <span class="keyword">for</span> quadric intersection <span class="number">123</span>&gt;</div><div class="line">        &lt;Compute rayEpsilon <span class="keyword">for</span> quadric intersection <span class="number">123</span>&gt;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-3-4-局部柱面"><a href="#3-3-4-局部柱面" class="headerlink" title="3.3.4 局部柱面"></a>3.3.4 局部柱面</h3><p>流程和球面是相同的。首先，逆三角函数得到φ。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Compute cylinder hit point and φ&gt; ≡ <span class="number">127</span>, <span class="number">128</span></div><div class="line">    phit = ray(thit);</div><div class="line">    phi = atan2f(phit.y, phit.x);</div><div class="line">    <span class="keyword">if</span> (phi &lt; <span class="number">0.</span>)</div><div class="line">    &#123;</div><div class="line">        phi += <span class="number">2.f</span>*M_PI;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>确保顶点t没有被z和φ的限定条件剪裁掉。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;Test cylinder intersection against clipping parameters&gt; ≡ <span class="number">127</span></div><div class="line">    <span class="keyword">if</span> (phit.z &lt; zmin || phit.z &gt; zmax || phi &gt; phiMax)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (thit == t1)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        thit = t1;</div><div class="line">        <span class="keyword">if</span> (t1 &gt; ray.maxt)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        &lt;Compute cylinder hit point and φ <span class="number">127</span>&gt;</div><div class="line">        <span class="keyword">if</span> (phit.z &lt; zmin || phit.z &gt; zmax || phi &gt; phiMax)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>将f（φ，z）映射到f（u，v）。这也是计算偏导数的坐标前提。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Find parametric representation of cylinder hit&gt; ≡ <span class="number">127</span></div><div class="line">    <span class="keyword">float</span> u = phi / phiMax;</div><div class="line">    <span class="keyword">float</span> v = (phit.z - zmin) / (zmax - zmin);</div><div class="line">    &lt;Compute cylinder ∂p/∂u and ∂p/∂v <span class="number">128</span>&gt;</div><div class="line">    &lt;Compute cylinder ∂n/∂u and ∂n/∂v <span class="number">128</span>&gt;</div></pre></td></tr></table></figure></p>
<p>以下给出求得的圆柱偏导数结果。<br>$$\frac{\partial p}{\partial u}=(-\phi<em>{max}y,\phi</em>{max}x,0)\<br>\frac{\partial p}{\partial v}=(0,0,z<em>{max}-z</em>{min})$$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Compute cylinder ∂p/∂u and ∂p/∂v&gt; ≡ <span class="number">128</span></div><div class="line">    <span class="function">Vector <span class="title">dpdu</span><span class="params">(-phiMax * phit.y, phiMax * phit.x, <span class="number">0</span>)</span></span>;</div><div class="line">    <span class="function">Vector <span class="title">dpdv</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, zmax - zmin)</span></span>;</div></pre></td></tr></table></figure></p>
<p>出来吧，Weingarten Equations！<br>$$\frac{\partial^2p}{\partial u^2}=-\phi^2_{max}(x,y,0) \quad<br>\frac{\partial^2p}{\partial u \partial v}=\frac{\partial^2p}{\partial v^2}=(0,0,0)<br>$$<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Compute cylinder ∂n/∂u and ∂n/∂v&gt; ≡ 128</div><div class="line">    Vector d2Pduu = -phiMax * phiMax * Vector(phit.x, phit.y, 0);</div><div class="line">    Vector d2Pduv(0, 0, 0), d2Pdvv(0, 0, 0);</div><div class="line">    &lt;Compute coefficients for fundamental forms 122&gt;</div><div class="line">    &lt;Compute ∂n/∂u and ∂n/∂v from fundamental form coefficients 122&gt;</div></pre></td></tr></table></figure></p>
<h3 id="3-3-5-表面积"><a href="#3-3-5-表面积" class="headerlink" title="3.3.5 表面积"></a>3.3.5 表面积</h3><p>没错，矩形而已。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Cylinder Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">float</span> Cylinder::Area() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> (zmax-zmin) * phiMax * radius;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-4-圆盘-P158"><a href="#3-4-圆盘-P158" class="headerlink" title="3.4 圆盘 P158"></a>3.4 圆盘 P158</h2><p>圆盘的有趣之处在于，求交不需解二元一次方程。详见shapes/disk.h和shapes/disk.cpp。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Disk Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> Disk : <span class="keyword">public</span> Shape</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;Disk Public Methods&gt;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        &lt;Disk Private Data <span class="number">130</span>&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<h3 id="3-4-1-构造"><a href="#3-4-1-构造" class="headerlink" title="3.4.1 构造"></a>3.4.1 构造</h3><p>给定内外半径ri与r，z轴范围高度h和φ的最大值即可确定圆盘。<br>$$\phi=u\phi_{max}\<br>x=((1-v)r_i+vr)\cos\phi\<br>y=((1-v)r_i=vr)\sin\phi\<br>z=h$$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;Disk Method Definitions&gt; ≡</div><div class="line">    Disk::Disk(const Transform *o2w, const Transform *w2o, bool ro,</div><div class="line">               float ht, float r, float ri, float tmax)</div><div class="line">        : Shape(o2w, w2o, ro)</div><div class="line">    &#123;</div><div class="line">        height = ht;</div><div class="line">        radius = r;</div><div class="line">        innerRadius = ri;</div><div class="line">        phiMax = Radians(Clamp(tmax, 0.0f, 360.0f));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Disk Private Data&gt; ≡ 129</div><div class="line">    float height, radius, innerRadius, phiMax;</div></pre></td></tr></table></figure></p>
<h3 id="3-4-2-边界"><a href="#3-4-2-边界" class="headerlink" title="3.4.2 边界"></a>3.4.2 边界</h3><p>包围盒即某高度下的边界框。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Disk Method Definitions&gt; +≡</div><div class="line">    BBox Disk::ObjectBound() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> BBox(Point(-radius, -radius, height),</div><div class="line">                    Point( radius, radius, height));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-4-3-交点"><a href="#3-4-3-交点" class="headerlink" title="3.4.3 交点"></a>3.4.3 交点</h3><p>首先确定光线是否与平面z=h相交，其次确定交点是否在圆盘内。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;Disk Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">bool</span> Disk::Intersect(<span class="keyword">const</span> Ray &amp;r, <span class="keyword">float</span> *tHit, <span class="keyword">float</span> *rayEpsilon,</div><div class="line">                         DifferentialGeometry *dg) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        &lt;Transform Ray to object space <span class="number">117</span>&gt;</div><div class="line">        &lt;Compute plane intersection <span class="keyword">for</span> disk <span class="number">131</span>&gt;</div><div class="line">        &lt;See <span class="keyword">if</span> hit point is inside disk radii and φmax <span class="number">132</span>&gt;</div><div class="line">        &lt;Find parametric representation of disk hit <span class="number">132</span>&gt;</div><div class="line">        &lt;Initialize DifferentialGeometry from parametric information <span class="number">122</span>&gt;</div><div class="line">        &lt;Update tHit <span class="keyword">for</span> quadric intersection <span class="number">123</span>&gt;</div><div class="line">        &lt;Compute rayEpsilon <span class="keyword">for</span> quadric intersection <span class="number">123</span>&gt;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>将光线参数方程的z分量代入z=h中。<br>$$h=o_z+td_z$$<br>若t值为零，则与z=h面平行，无交。<br>非零，判断t是否在光线区间内。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;Compute plane intersection <span class="keyword">for</span> disk&gt; ≡ <span class="number">131</span></div><div class="line">    <span class="keyword">if</span> (fabsf(ray.d.z) &lt; <span class="number">1e-7</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">float</span> thit = (height - ray.o.z) / ray.d.z;</div><div class="line">    <span class="keyword">if</span> (thit &lt; ray.mint || thit &gt; ray.maxt)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果交点phit到圆盘中心的距离大于Disk::radius或小于Disk::innerRadius,那么它就落在了圆盘之外。尽量避免平方运算。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;See <span class="keyword">if</span> hit point is inside disk radii and φmax&gt; ≡ <span class="number">131</span></div><div class="line">    Point phit = ray(thit);</div><div class="line">    <span class="keyword">float</span> dist2 = phit.x * phit.x + phit.y * phit.y;</div><div class="line">    <span class="keyword">if</span> (dist2 &gt; radius * radius || dist2 &lt; innerRadius * innerRadius)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    &lt;Test disk φ value against φmax <span class="number">132</span>&gt;</div></pre></td></tr></table></figure></p>
<p>交点位于内外半径内，检查是否在φ的区间内。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;Test disk φ value against φmax&gt; ≡ <span class="number">132</span></div><div class="line">    <span class="keyword">float</span> phi = atan2f(phit.y, phit.x);</div><div class="line">    <span class="keyword">if</span> (phi &lt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        phi += <span class="number">2.</span> * M_PI;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (phi &gt; phiMax)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>走到这里，可以确定交点位于圆盘内。最后的工作同上，映射到f（u，v），计算出偏导数。幸运的是，圆盘上的法向量都相同，法线偏导数为零。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;Find parametric representation of disk hit&gt; ≡ 131</div><div class="line">    float u = phi / phiMax;</div><div class="line">    float v = 1.f - ((sqrtf(dist2)-innerRadius) /</div><div class="line">                     (radius-innerRadius));</div><div class="line">    Vector dpdu(-phiMax * phit.y, phiMax * phit.x, 0.);</div><div class="line">    Vector dpdv(-phit.x / (1-v), -phit.y / (1-v), 0.);</div><div class="line">    dpdu *= phiMax * INV_TWOPI;</div><div class="line">    dpdv *= (radius - innerRadius) / radius;</div><div class="line">    Normal dndu(0,0,0), dndv(0,0,0);</div></pre></td></tr></table></figure></p>
<h3 id="3-4-4-表面积"><a href="#3-4-4-表面积" class="headerlink" title="3.4.4 表面积"></a>3.4.4 表面积</h3><p>环的表面积。<br>$$S=\frac{\phi_{max}}{2}(r^2-r_i^2)$$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Disk Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">float</span> Disk::Area() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> phiMax * <span class="number">0.5f</span> *(radius * radius - innerRadius * innerRadius);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-5-其他二次曲线-P162"><a href="#3-5-其他二次曲线-P162" class="headerlink" title="3.5 其他二次曲线 P162"></a>3.5 其他二次曲线 P162</h2><p>PBRT提供的其他三种二次曲线：圆锥面收录于shapes/cone.h和shapes/cone.cpp；抛物面收录于shapes/paraboloid.h和shapes/paraboloid.cpp；双曲面收录于shapes/hyperboloid.h和shapes/hyperboloid.cpp。不再一一叙述，只摘录部分公式。</p>
<h3 id="3-5-1-圆锥面"><a href="#3-5-1-圆锥面" class="headerlink" title="3.5.1 圆锥面"></a>3.5.1 圆锥面</h3><p>隐式方程：<br>$$(\frac{hx}{r})^2+(\frac{hy}{r})^2-(z-h)^2=0$$<br>参数方程：<br>$$\phi=u\phi<em>{max}\<br>x=r(1-v)\cos\phi\<br>y=r(1-v)\sin\phi\<br>z=vh$$<br>一阶偏导数：<br>$$\frac{\partial p}{\partial u}=(-\phi</em>{max}y,\phi<em>{max}x,0)\<br>\frac{\partial p}{\partial v}=(-\frac{x}{1-v},\frac{y}{1-v},h)$$<br>二阶偏导数：<br>$$\frac{\partial^2p}{\partial u^2}=-\phi^2</em>{max}(x,y,0)\<br>\frac{\partial^2p}{\partial u\partial v}=\frac{\phi_{max}}{1-v}(y,-x,0)\<br>\frac{\partial^2p}{\partial v^2}=(0,0,0)$$</p>
<h3 id="3-5-2-双曲面"><a href="#3-5-2-双曲面" class="headerlink" title="3.5.2 双曲面"></a>3.5.2 双曲面</h3><p>隐式方程：<br>$$(\frac{hx}{r})^2+(\frac{hy}{r})^2-z=0$$<br>参数方程：<br>$$\phi=u\phi<em>{max}\<br>z=v(z</em>{max}-z<em>{min})\<br>r=r</em>{max}\sqrt{\frac{z}{z<em>{max}}}\<br>x=r\cos\phi\<br>y=r\sin\phi$$<br>一阶偏导数：<br>$$\frac{\partial p}{\partial u}=(-\phi</em>{max}y,\phi<em>{max}x,0)\<br>\frac{\partial p}{\partial v}=(z</em>{max}-z<em>{min})(\frac{x}{2z},\frac{y}{2z},1)$$<br>二阶偏导数：<br>$$\frac{\partial^2p}{\partial u^2}=-\phi^2</em>{max}(x,y,0)\<br>\frac{\partial^2p}{\partial u\partial v}=\phi<em>{max}(z</em>{max}-z<em>{min})(-\frac{y}{2z},\frac{x}{2z},0)\\frac{\partial^2p}{\partial v^2}=-(z</em>{max}-z_{min})^2(\frac{x}{4z^2},\frac{y}{4z^2},0)$$</p>
<h3 id="3-5-3-抛物面"><a href="#3-5-3-抛物面" class="headerlink" title="3.5.3 抛物面"></a>3.5.3 抛物面</h3><p>隐式方程：<br>$$x^2+y^2-z^2=-1$$<br>参数方程：<br>$$\phi=u\phi_{max}\<br>x_r=(1-v)x_1+vx_2\<br>y_r=(1-v)y_1+vy_2\<br>x=x_r\cos\phi-y_r\sin\phi\<br>y=x_r\sin\phi+y_r\cos\phi\<br>z=(1-v)z_1+vz<em>2$$<br>一阶偏导数：<br>$$\frac{\partial p}{\partial u}=(-\phi</em>{max}y,\phi_{max}x,0)\<br>\frac{\partial p}{\partial v}=((x_2-x_1)\cos\phi-(y_2-y_1)\sin\phi,(x_2-x_1)\sin\phi+(y_2-y_1)\cos\phi,z_2-z<em>1)$$<br>二阶偏导数：<br>$$\frac{\partial^2p}{\partial u^2}=-\phi^2</em>{max}(x,y,0)\<br>\frac{\partial^2p}{\partial u\partial v}=\phi_{max}(-\frac{\partial p_y}{\partial v},\frac{\partial p_x}{\partial v},0)\\frac{\partial^2p}{\partial v^2}=(0,0,0)$$</p>
<h2 id="3-6-三角形与网格-P164"><a href="#3-6-三角形与网格-P164" class="headerlink" title="3.6 三角形与网格 P164"></a>3.6 三角形与网格 P164</h2><p>PBRT提供了三角网格，它可以存贮大量三角形，其中的三角形共享顶点数据。TriangleMesh的构造器需要以下变量：</p>
<ul>
<li>nt：三角形数量</li>
<li>nv：顶点数量</li>
<li>vi：指向顶点索引数组的指针，例如：第i个三角形，其三个顶点的位置为P[vi[3<em>i]]，P[vi[3</em>i+1]]，P[vi[3*i+2]]</li>
<li>P：存储nv个顶点位置的数组</li>
<li>N：网格中每个顶点的法向量，可选，用于插值计算着色微分几何信息</li>
<li>S：网格中每个顶点的切向量，可选，用处同上</li>
<li>uv：网格中每个顶点的（u，v）参数数组，可选</li>
<li>atex：α遮罩贴图（Alpha Mask Texture），可选，用于切除三角形面的部分</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;TriangleMesh Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> TriangleMesh : <span class="keyword">public</span> Shape</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;TriangleMesh Public Methods <span class="number">138</span>&gt;</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">        &lt;TriangleMesh Protected Data <span class="number">137</span>&gt;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&lt;TriangleMesh Protected Data&gt; ≡ <span class="number">135</span></div><div class="line">    <span class="keyword">int</span> ntris, nverts;</div><div class="line">    <span class="keyword">int</span> *vertexIndex;</div><div class="line">    Point *p;</div><div class="line">    Normal *n;</div><div class="line">    Vector *s;</div><div class="line">    <span class="keyword">float</span> *uvs;</div><div class="line">    Reference&lt;Texture&lt;<span class="keyword">float</span>&gt; &gt; alphaTexture;</div></pre></td></tr></table></figure>
<p>PBRT中三角形着两个角色：其一，是用户提供的几何体；其二，是其它基本几何体细分成三角形网格的结果。例如，曲面细分的结果会生成接近曲面的三角网格。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;TriangleMesh Method Definitions&gt; ≡</div><div class="line">    TriangleMesh::TriangleMesh(<span class="keyword">const</span> Transform *o2w, <span class="keyword">const</span> Transform *w2o,</div><div class="line">                               <span class="keyword">bool</span> ro, <span class="keyword">int</span> nt, <span class="keyword">int</span> nv, <span class="keyword">const</span> <span class="keyword">int</span> *vi, <span class="keyword">const</span> Point *P,</div><div class="line">                               <span class="keyword">const</span> Normal *N, <span class="keyword">const</span> Vector *S, <span class="keyword">const</span> <span class="keyword">float</span> *uv,</div><div class="line">                               <span class="keyword">const</span> Reference&lt;Texture&lt;<span class="keyword">float</span>&gt; &gt; &amp;atex)</div><div class="line">        : Shape(o2w, w2o, ro), alphaTexture(atex)</div><div class="line">    &#123;</div><div class="line">        ntris = nt;</div><div class="line">        nverts = nv;</div><div class="line">        vertexIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span> * ntris];</div><div class="line">        <span class="built_in">memcpy</span>(vertexIndex, vi, <span class="number">3</span> * ntris * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">        &lt;Copy uv, N, and S vertex data, <span class="keyword">if</span> present&gt;</div><div class="line">        &lt;Transform mesh vertices to world space <span class="number">138</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>之前的其他形体都是在对象空间中完成定义，将光线进行W2O处理，但三角网格相反，将网格O2W至世界空间，避免了渲染过程中光线的反复变换。着色几何信息的法向量和切向量留在对象空间中，因为GetShadingGeometry()必须使用所传入的变换矩阵完成O2W，而不一定用存储在Shape中的变换矩阵。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Transform mesh vertices to world space&gt; ≡ <span class="number">137</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nverts; ++i)</div><div class="line">    &#123;</div><div class="line">        p[i] = (*ObjectToWorld)(P[i]);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>包围盒很容易计算。但这步消耗颇大，如果数据可被重用，应暂存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;TriangleMesh Method Definitions&gt; +≡</div><div class="line">    BBox TriangleMesh::ObjectBound() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        BBox objectBounds;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nverts; i++)</div><div class="line">        &#123;</div><div class="line">            objectBounds = Union(objectBounds, (*WorldToObject)(p[i]));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> objectBounds;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>TriangleMesh也可在世界空间下直接计算包围盒，这个结果甚至可能比在对象空间中更好。<br>网格本身不能求交点。实际上，它将自己分解为若干独立的三角形，所有这些独立的三角形引用数组p的顶点以避免共享数据的反复复制。为此，网格重写Shape::CanIntersect()阐明自己不可求交。<br>同样的，必须重写Shape::Refine()完成细分。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;TriangleMesh Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">void</span> TriangleMesh::Refine(<span class="built_in">vector</span>&lt;Reference&lt;Shape&gt; &gt; &amp;refined) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ntris; ++i)</div><div class="line">        &#123;</div><div class="line">            refined.push_back(<span class="keyword">new</span> Triangle(ObjectToWorld,</div><div class="line">                              WorldToObject, ReverseOrientation,</div><div class="line">                              (TriangleMesh *)<span class="keyword">this</span>, i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-6-1-三角形"><a href="#3-6-1-三角形" class="headerlink" title="3.6.1 三角形"></a>3.6.1 三角形</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;TriangleMesh Declarations&gt; +≡</div><div class="line">    <span class="keyword">class</span> Triangle : <span class="keyword">public</span> Shape</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;Triangle Public Methods <span class="number">139</span>&gt;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        &lt;Triangle Private Data <span class="number">139</span>&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>Triangle类只有一个指向其父对象TriangleMesh的指针和一个指向其三个顶点索引值的指针。注意，只存放指向第一个顶点索引值的指针，而不是存放三个指向其三个顶点的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;Triangle Public Methods&gt; ≡ <span class="number">139</span></div><div class="line">    Triangle(<span class="keyword">const</span> Transform *o2w, <span class="keyword">const</span> Transform *w2o, <span class="keyword">bool</span> ro,</div><div class="line">             TriangleMesh *m, <span class="keyword">int</span> n)</div><div class="line">        : Shape(o2w, w2o, ro)</div><div class="line">    &#123;</div><div class="line">        mesh = m;</div><div class="line">        v = &amp;mesh-&gt;vertexIndex[<span class="number">3</span>*n];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Triangle Private Data&gt; ≡ <span class="number">139</span></div><div class="line">    Reference&lt;TriangleMesh&gt; mesh;</div><div class="line">    <span class="keyword">int</span> *v;</div><div class="line"></div><div class="line">&lt;Get triangle vertices in p1, p2, and p3&gt; ≡ <span class="number">139</span>, <span class="number">140</span>, <span class="number">141</span>, <span class="number">145</span>, <span class="number">719</span></div><div class="line">    <span class="keyword">const</span> Point &amp;p1 = mesh-&gt;p[v[<span class="number">0</span>]];</div><div class="line">    <span class="keyword">const</span> Point &amp;p2 = mesh-&gt;p[v[<span class="number">1</span>]];</div><div class="line">    <span class="keyword">const</span> Point &amp;p3 = mesh-&gt;p[v[<span class="number">2</span>]];</div></pre></td></tr></table></figure></p>
<p>同网格，三角形的包围盒也能在O和W两个空间下求得。</p>
<h3 id="3-6-2-三角形交点"><a href="#3-6-2-三角形交点" class="headerlink" title="3.6.2 三角形交点"></a>3.6.2 三角形交点</h3><p>这里简单给出求交过程，不再按步推导。<br>首先利用重心坐标系提供的变量b1、b2参数化表示三角形；之后，光线方程代入三角方程；之后，变形为矩阵方程；最后，克莱姆法则求解t b1 b2。<br>$$\begin{pmatrix}-d&amp;e_1&amp;e_2\end{pmatrix}\begin{bmatrix}t\b_1\b_2\end{bmatrix}=s\<br>\begin{bmatrix}t\b_1\b_2\end{bmatrix}=\frac{1}{|-d\quad e_1\quad e_2|}\begin{bmatrix}|\quad s&amp;e_1&amp;e_2|\|-d&amp;s&amp;e_2|\|-d&amp;e_1&amp;s|\end{bmatrix}<br>$$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;TriangleMesh Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">bool</span> Triangle::Intersect(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">float</span> *tHit, <span class="keyword">float</span> *rayEpsilon,</div><div class="line">                             DifferentialGeometry *dg) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        &lt;Compute s1 <span class="number">141</span>&gt;</div><div class="line">        &lt;Compute first barycentric coordinate <span class="number">142</span>&gt;</div><div class="line">        &lt;Compute second barycentric coordinate <span class="number">142</span>&gt;</div><div class="line">        &lt;Compute t to intersection point <span class="number">142</span>&gt;</div><div class="line">        &lt;Compute triangle partial derivatives <span class="number">143</span>&gt;</div><div class="line">        &lt;Interpolate (u, v) triangle parametric coordinates <span class="number">143</span>&gt;</div><div class="line">        &lt;Test intersection against alpha texture, <span class="keyword">if</span> present <span class="number">144</span>&gt;</div><div class="line">        &lt;Fill in DifferentialGeometry from triangle hit <span class="number">145</span>&gt;</div><div class="line">        *tHit = t;</div><div class="line">        *rayEpsilon = <span class="number">1e-3</span>f * *tHit;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先计算分母。分母为零时不存在交点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;Compute s1&gt; ≡ <span class="number">141</span></div><div class="line">    &lt;Get triangle vertices in p1, p2, and p3 <span class="number">140</span>&gt;</div><div class="line">    Vector e1 = p2 - p1;</div><div class="line">    Vector e2 = p3 - p1;</div><div class="line">    Vector s1 = Cross(ray.d, e2);</div><div class="line">    <span class="keyword">float</span> divisor = Dot(s1, e1);</div><div class="line">    <span class="keyword">if</span> (divisor == <span class="number">0.</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">float</span> invDivisor = <span class="number">1.f</span> / divisor;</div></pre></td></tr></table></figure></p>
<p>计算重心坐标。重心坐标位于[0，1]外则表示点在三角形外，没有交点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Compute first barycentric coordinate&gt; ≡ <span class="number">141</span></div><div class="line">    Vector d = ray.o - p1;</div><div class="line">    <span class="keyword">float</span> b1 = Dot(d, s1) * invDivisor;</div><div class="line">    <span class="keyword">if</span> (b1 &lt; <span class="number">0.</span> || b1 &gt; <span class="number">1.</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Compute second barycentric coordinate&gt; ≡ <span class="number">141</span></div><div class="line">    Vector s2 = Cross(d, e1);</div><div class="line">    <span class="keyword">float</span> b2 = Dot(ray.d, s2) * invDivisor;</div><div class="line">    <span class="keyword">if</span> (b2 &lt; <span class="number">0.</span> || b1 + b2 &gt; <span class="number">1.</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>此时可以计算光线离交点的距离。不要忘记Ray::mint和Ray::maxt的范围。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Compute t to intersection point&gt; ≡ <span class="number">141</span></div><div class="line">    <span class="keyword">float</span> t = Dot(e2, s2) * invDivisor;</div><div class="line">    <span class="keyword">if</span> (t &lt; ray.mint || t &gt; ray.maxt)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>要着手处理DifferentialGeometry了。三角形是满足下列条件的点的集合，其中，p0是某一点。<br>$$p_0+u\frac{\partial p}{\partial u}+v\frac{\partial p}{\partial v}$$<br>我们还知道三角形每个点的坐标pi和纹理坐标（ui，vi），其中i取1，2，3。<br>$$p_i=p_0+u_i\frac{\partial p}{\partial u}+v_i\frac{\partial p}{\partial v}$$<br>交叉相减并联立，∂p/∂u和∂p/∂v可求。显然，法线偏导数为零，皆大欢喜。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;Compute triangle partial derivatives&gt; ≡ <span class="number">141</span></div><div class="line">    Vector dpdu, dpdv;</div><div class="line">    <span class="keyword">float</span> uvs[<span class="number">3</span>][<span class="number">2</span>];</div><div class="line">    GetUVs(uvs);</div><div class="line">    &lt;Compute deltas <span class="keyword">for</span> triangle partial derivatives <span class="number">143</span>&gt;</div><div class="line">    <span class="keyword">float</span> determinant = du1 * dv2 - dv1 * du2;</div><div class="line">    <span class="keyword">if</span> (determinant == <span class="number">0.f</span>)</div><div class="line">    &#123;</div><div class="line">        &lt;Handle zero determinant <span class="keyword">for</span> triangle partial derivative matrix <span class="number">143</span>&gt;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">float</span> invdet = <span class="number">1.f</span> / determinant;</div><div class="line">        dpdu = ( dv2 * dp1 - dv1 * dp2) * invdet;</div><div class="line">        dpdv = (-du2 * dp1 + du1 * dp2) * invdet;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Compute deltas <span class="keyword">for</span> triangle partial derivatives&gt; ≡ <span class="number">143</span></div><div class="line">    <span class="keyword">float</span> du1 = uvs[<span class="number">0</span>][<span class="number">0</span>] - uvs[<span class="number">2</span>][<span class="number">0</span>];</div><div class="line">    <span class="keyword">float</span> du2 = uvs[<span class="number">1</span>][<span class="number">0</span>] - uvs[<span class="number">2</span>][<span class="number">0</span>];</div><div class="line">    <span class="keyword">float</span> dv1 = uvs[<span class="number">0</span>][<span class="number">1</span>] - uvs[<span class="number">2</span>][<span class="number">1</span>];</div><div class="line">    <span class="keyword">float</span> dv2 = uvs[<span class="number">1</span>][<span class="number">1</span>] - uvs[<span class="number">2</span>][<span class="number">1</span>];</div><div class="line">    Vector dp1 = p1 - p3, dp2 = p2 - p3;</div></pre></td></tr></table></figure></p>
<p>最后，考虑矩阵奇异这个特殊情况，当然这种情况只会在用户提供的三角形顶点数据退化的情况下才会触发。这时Triangle选择一个由法线生成的任意坐标系。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Handle zero determinant <span class="keyword">for</span> triangle partial derivative matrix&gt; ≡ <span class="number">143</span></div><div class="line">    CoordinateSystem(Normalize(Cross(e2, e1)), &amp;dpdu, &amp;dpdv);</div></pre></td></tr></table></figure></p>
<p>为了计算交点处的(u,v)值，要利用三个顶点的(u,v)值和重心坐标公式。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Interpolate (u, v) triangle parametric coordinates&gt; ≡ <span class="number">141</span></div><div class="line">    <span class="keyword">float</span> b0 = <span class="number">1</span> - b1 - b2;</div><div class="line">    <span class="keyword">float</span> tu = b0*uvs[<span class="number">0</span>][<span class="number">0</span>] + b1*uvs[<span class="number">1</span>][<span class="number">0</span>] + b2*uvs[<span class="number">2</span>][<span class="number">0</span>];</div><div class="line">    <span class="keyword">float</span> tv = b0*uvs[<span class="number">0</span>][<span class="number">1</span>] + b1*uvs[<span class="number">1</span>][<span class="number">1</span>] + b2*uvs[<span class="number">2</span>][<span class="number">1</span>];</div></pre></td></tr></table></figure></p>
<p>函数GetUVs()用于从网格中返回三角形顶点的（u，v）坐标，网格不存在时使用缺省值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;Triangle Public Methods&gt; +≡ <span class="number">139</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetUVs</span><span class="params">(<span class="keyword">float</span> uv[<span class="number">3</span>][<span class="number">2</span>])</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (mesh-&gt;uvs)</div><div class="line">        &#123;</div><div class="line">            uv[<span class="number">0</span>][<span class="number">0</span>] = mesh-&gt;uvs[<span class="number">2</span>*v[<span class="number">0</span>]];</div><div class="line">            uv[<span class="number">0</span>][<span class="number">1</span>] = mesh-&gt;uvs[<span class="number">2</span>*v[<span class="number">0</span>]+<span class="number">1</span>];</div><div class="line">            uv[<span class="number">1</span>][<span class="number">0</span>] = mesh-&gt;uvs[<span class="number">2</span>*v[<span class="number">1</span>]];</div><div class="line">            uv[<span class="number">1</span>][<span class="number">1</span>] = mesh-&gt;uvs[<span class="number">2</span>*v[<span class="number">1</span>]+<span class="number">1</span>];</div><div class="line">            uv[<span class="number">2</span>][<span class="number">0</span>] = mesh-&gt;uvs[<span class="number">2</span>*v[<span class="number">2</span>]];</div><div class="line">            uv[<span class="number">2</span>][<span class="number">1</span>] = mesh-&gt;uvs[<span class="number">2</span>*v[<span class="number">2</span>]+<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            uv[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0.</span>; uv[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0.</span>;</div><div class="line">            uv[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1.</span>; uv[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0.</span>;</div><div class="line">            uv[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1.</span>; uv[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1.</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>最后的最后，上传交点数据前的最后一件事，测试交点是否通过α遮罩纹理。这个纹理可被视为三角形面上的一维函数（……），它所在之处数值为零且交点被忽略。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Test intersection against alpha texture, if present&gt; ≡ 141</div><div class="line">    if (mesh-&gt;alphaTexture)</div><div class="line">    &#123;</div><div class="line">        DifferentialGeometry dgLocal(ray(t), dpdu, dpdv,</div><div class="line">        Normal(0,0,0), Normal(0,0,0), tu, tv, this);</div><div class="line">        if (mesh-&gt;alphaTexture-&gt;Evaluate(dgLocal) == 0.f)</div><div class="line">        &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Fill in DifferentialGeometry from triangle hit&gt; ≡ 141</div><div class="line">    *dg = DifferentialGeometry(ray(t), dpdu, dpdv,</div><div class="line">    Normal(0,0,0), Normal(0,0,0),</div><div class="line">    tu, tv, this);</div></pre></td></tr></table></figure></p>
<h3 id="3-6-3-表面积"><a href="#3-6-3-表面积" class="headerlink" title="3.6.3 表面积"></a>3.6.3 表面积</h3><p>丢码跑。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;TriangleMesh Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">float</span> Triangle::Area() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        &lt;Get triangle vertices in p1, p2, and p3 <span class="number">140</span>&gt;</div><div class="line">        <span class="keyword">return</span> <span class="number">0.5f</span> * Cross(p2-p1, p3-p1).Length();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-6-4-着色几何"><a href="#3-6-4-着色几何" class="headerlink" title="3.6.4 着色几何"></a>3.6.4 着色几何</h3><p>如果TriangleMesh本身提供了每个顶点的法切向量数据，函数GetShadingGeometry()直接借用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;TriangleMesh Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">void</span> Triangle::GetShadingGeometry(<span class="keyword">const</span> Transform &amp;obj2world,</div><div class="line">                                      <span class="keyword">const</span> DifferentialGeometry &amp;dg,</div><div class="line">                                      DifferentialGeometry *dgShading) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (!mesh-&gt;n &amp;&amp; !mesh-&gt;s)</div><div class="line">        &#123;</div><div class="line">            *dgShading = dg;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        &lt;Initialize Triangle shading geometry with n and s <span class="number">146</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>考虑到DifferentialGeometry存有参数（u，v），但并不保存交点的重心坐标数据。所以第一个任务是复现其重心坐标，此外还需计算插值的法向量和s向量，再将它们转换成两个切向量，填充到DifferentialGeometry的构造函数中。最后，得到着色用的法向量的偏导数，完成着色几何结构的初始化。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Initialize Triangle shading geometry with n and s&gt; ≡ <span class="number">145</span></div><div class="line">    &lt;Compute barycentric coordinates <span class="keyword">for</span> point <span class="number">147</span>&gt;</div><div class="line">    &lt;Use n and s to compute shading tangents <span class="keyword">for</span> triangle, ss and ts <span class="number">147</span>&gt;</div><div class="line">    Normal dndu, dndv;</div><div class="line">    &lt;Compute ∂n/∂u and ∂n/∂v <span class="keyword">for</span> triangle shading geometry&gt;</div><div class="line">    *dgShading = DifferentialGeometry(dg.p, ss, ts,</div><div class="line">                                      (*ObjectToWorld)(dndu), (*ObjectToWorld)(dndv),</div><div class="line">                                      dg.u, dg.v, dg.shape);</div></pre></td></tr></table></figure></p>
<p>回忆，三角形DifferentialGeometry中的参数坐标（u，v）是通过对三角形顶点上的参数值插值而得到的：<br>$$u=(1-b_1-b_2)+b_1u_1+b_2u_2\<br>v=(1-b_1-b_2)+b_1v_1+b_2v_2$$<br>现在，可以得到重心坐标bi了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;Compute barycentric coordinates <span class="keyword">for</span> point&gt; ≡ <span class="number">146</span></div><div class="line">    <span class="keyword">float</span> b[<span class="number">3</span>];</div><div class="line">    &lt;Initialize A and C matrices <span class="keyword">for</span> barycentrics <span class="number">147</span>&gt;</div><div class="line">    <span class="keyword">if</span> (!SolveLinearSystem2x2(A, C, &amp;b[<span class="number">1</span>], &amp;b[<span class="number">2</span>]))</div><div class="line">    &#123;</div><div class="line">        &lt;Handle degenerate parametric mapping <span class="number">147</span>&gt;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        b[<span class="number">0</span>] = <span class="number">1.f</span> - b[<span class="number">1</span>] - b[<span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&lt;Initialize A and C matrices <span class="keyword">for</span> barycentrics&gt; ≡ <span class="number">147</span></div><div class="line">    <span class="keyword">float</span> uv[<span class="number">3</span>][<span class="number">2</span>];</div><div class="line">    GetUVs(uv);</div><div class="line">    <span class="keyword">float</span> A[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123; uv[<span class="number">1</span>][<span class="number">0</span>] - uv[<span class="number">0</span>][<span class="number">0</span>], uv[<span class="number">2</span>][<span class="number">0</span>] - uv[<span class="number">0</span>][<span class="number">0</span>] &#125;,</div><div class="line">                      &#123; uv[<span class="number">1</span>][<span class="number">1</span>] - uv[<span class="number">0</span>][<span class="number">1</span>], uv[<span class="number">2</span>][<span class="number">1</span>] - uv[<span class="number">0</span>][<span class="number">1</span>] &#125; &#125;;</div><div class="line">    <span class="keyword">float</span> C[<span class="number">2</span>] = &#123; dg.u - uv[<span class="number">0</span>][<span class="number">0</span>], dg.v - uv[<span class="number">0</span>][<span class="number">1</span>] &#125;;</div></pre></td></tr></table></figure></p>
<p>特殊条件下，如三角形的三个顶点含有相同的纹理坐标时，A的行列式值为零，无解，SolveLinearSystem2x2（）返回false，此时重心坐标都设为1/3。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Handle degenerate parametric mapping&gt; ≡ <span class="number">147</span></div><div class="line">    b[<span class="number">0</span>] = b[<span class="number">1</span>] = b[<span class="number">2</span>] = <span class="number">1.f</span>/<span class="number">3.f</span>;</div></pre></td></tr></table></figure></p>
<p>通过插值适当的顶点法向量和切向量计算着色法向量和着色s切向量。首先，DifferentialGeometry的ts向量可以由ss和ns叉乘得到；其次，用ns和ts的叉乘结果覆盖掉ss，再用新的ss和ts的叉积得到ns。这样一来，如果提供了顶点上n和s向量，当n和s插值后所得到的向量并不正交时，n保持不变，s要做些修正，使得两者保持正交。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;Use n and s to compute shading tangents <span class="keyword">for</span> triangle, ss and ts&gt; ≡ <span class="number">146</span></div><div class="line">    Normal ns;</div><div class="line">    Vector ss, ts;</div><div class="line">    <span class="keyword">if</span> (mesh-&gt;n)</div><div class="line">    &#123;</div><div class="line">        ns = Normalize(obj2world(b[<span class="number">0</span>] * mesh-&gt;n[v[<span class="number">0</span>]] +</div><div class="line">                       b[<span class="number">1</span>] * mesh-&gt;n[v[<span class="number">1</span>]] +</div><div class="line">                       b[<span class="number">2</span>] * mesh-&gt;n[v[<span class="number">2</span>]]));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        ns = dg.nn;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mesh-&gt;s)</div><div class="line">    &#123;</div><div class="line">        ss = Normalize(obj2world(b[<span class="number">0</span>] * mesh-&gt;s[v[<span class="number">0</span>]] +</div><div class="line">                       b[<span class="number">1</span>] * mesh-&gt;s[v[<span class="number">1</span>]] +</div><div class="line">                       b[<span class="number">2</span>] * mesh-&gt;s[v[<span class="number">2</span>]]));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        ss = Normalize(dg.dpdu);</div><div class="line">    &#125;</div><div class="line">    ts = Cross(ss, ns);</div><div class="line">    <span class="keyword">if</span> (ts.LengthSquared() &gt; <span class="number">0.f</span>)</div><div class="line">    &#123;</div><div class="line">        ts = Normalize(ts);</div><div class="line">        ss = Cross(ts, ns);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        CoordinateSystem((Vector)ns, &amp;ss, &amp;ts);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>偏导数的计算大致相同，不再赘述。</p>
<h2 id="3-7-细分曲面-P177"><a href="#3-7-细分曲面-P177" class="headerlink" title="3.7 细分曲面 P177"></a>3.7 细分曲面 P177</h2><p>一个多边形网格所对应的细分曲面是通过重复地细分网格上的多边形而生成的。在这个细分过程中，新的多边形顶点位置是由旧的多边形顶点的加权组合而得到的。选定好细分规则后，这个细分过程如果无限地进行下去，最终逼近一个平滑的极限曲面。<br>它拥有以下的优势：</p>
<ul>
<li>相比于多边形网格，细分曲面是平滑的：前者的建模无论多么精细，在一定距离内总能看到平坦的刻面</li>
<li>现有的许多模型系统的基本技术仍可以用到细分曲面上，那些面向多边形网格的造型技术可以用来构造细分曲面的控制网格</li>
<li>细分曲面非常适合于描述有着复杂拓扑结构的形体，因为它们的控制网格可以有任意复杂的拓扑结构。而参数化的曲面模型则无法处理好复杂的拓扑结构</li>
<li>细分曲面方法常常是样条曲面表示的一般化方法，细分曲面的渲染器可以渲染样条曲面</li>
<li>只要对细分曲面的控制网格添加多边形就可以很容易的对曲面的局部添加细节，而这对样条曲面而言则困难得多</li>
</ul>
<p>这里我们要描述的是Loop细分曲面的实现，Charles Loop在他的硕士论文中第一次实现了这项技术。Loop细分曲面的控制网格由三角形构成，多于三个顶点的多边形要预先划分为多个三角形。在每个细分步骤中，所有三角形面要划分成四个子三角形面，新的顶点沿原网格的边被添加进来，其顶点位置由附近顶点的加权平均值算得。此外，原顶点的位置也要更新为其原位置和新添加的邻近顶点位置的加权平均值。这步所实现的技术是Hoppe et al对Loop方法的改进。我们不讨论这些权值是如何得到的，通过数学上的证明可以得知这些权值保证了极限曲面具有平滑性。</p>
<h3 id="3-7-1-网格的表示"><a href="#3-7-1-网格的表示" class="headerlink" title="3.7.1 网格的表示"></a>3.7.1 网格的表示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;LoopSubdiv Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> LoopSubdiv : <span class="keyword">public</span> Shape</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;LoopSubdiv Public Methods&gt;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        &lt;LoopSubdiv Private Methods <span class="number">163</span>&gt;</div><div class="line">        &lt;LoopSubdiv Private Data <span class="number">152</span>&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>LoopSubdiv的构造函数同TriangleMesh：每个三角面由三个顶点索引值表示，这些索引值给出了三个顶点在顶点数组P中的偏移量。这些数据决定了面与点的邻接关系。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;LoopSubdiv Method Definitions&gt; ≡</div><div class="line">    LoopSubdiv::LoopSubdiv(<span class="keyword">const</span> Transform *o2w, <span class="keyword">const</span> Transform *w2o,</div><div class="line">                           <span class="keyword">bool</span> ro, <span class="keyword">int</span> nfaces, <span class="keyword">int</span> nvertices,</div><div class="line">                           <span class="keyword">const</span> <span class="keyword">int</span> *vertexIndices, <span class="keyword">const</span> Point *P, <span class="keyword">int</span> nl)</div><div class="line">        : Shape(o2w, w2o, ro) &#123;</div><div class="line">    nLevels = nl;</div><div class="line">    &lt;Allocate LoopSubdiv vertices and faces <span class="number">151</span>&gt;</div><div class="line">    &lt;Set face to vertex pointers <span class="number">154</span>&gt;</div><div class="line">    &lt;Set neighbor pointers in faces <span class="number">156</span>&gt;</div><div class="line">    &lt;Finish vertex initialization <span class="number">158</span>&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后定义一SDVertex和SDFace两个结构，它们分别存放细分曲面的顶点数据和面数据。构造函数会为每个点申请SDVertex的实例，每个面同理。目前，它们尚未被初始化。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;Allocate LoopSubdiv vertices and faces&gt; ≡ <span class="number">151</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    SDVertex *verts = <span class="keyword">new</span> SDVertex[nvertices];</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nvertices; ++i)</div><div class="line">    &#123;</div><div class="line">        verts[i] = SDVertex(P[i]);</div><div class="line">        vertices.push_back(&amp;verts[i]);</div><div class="line">    &#125;</div><div class="line">    SDFace *fs = <span class="keyword">new</span> SDFace[nfaces];</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfaces; ++i)</div><div class="line">    &#123;</div><div class="line">        faces.push_back(&amp;fs[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;LoopSubdiv Private Data&gt; ≡ <span class="number">151</span></div><div class="line">    <span class="keyword">int</span> nLevels;</div><div class="line">    <span class="built_in">vector</span>&lt;SDVertex *&gt; vertices;</div><div class="line">    <span class="built_in">vector</span>&lt;SDFace *&gt; faces;</div></pre></td></tr></table></figure></p>
<p>Loop的细分规则和其他细分算法相似，假设控制网格是流型（Manifold）的——一个面最多由两个边共享。这样的网格可以是闭合的——所有面都通过它们的边跟其他面相邻；也可是开放的——存在一些面少于三个邻接面。LoopSubdiv均支持。与某一顶点直接相邻的顶点数目叫做该顶点的价（Valence）。价不等于6的内部顶点和价不等于4的边界顶点称为非正规顶点，其它的顶点称为正规顶点。Loop细分曲面除了在非正规顶点的地方外，处处平滑。<br>每个SDVertex存放了顶点位置P，一个指示其为正规或非正规顶点的布尔变量，还有一个只是其是否为边界顶点的布尔变量。它还有一个指向其任意一个邻接面的指针，以及一个指向下一级细分所产生的新顶点的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;LoopSubdiv Local Structures&gt; ≡</div><div class="line">    <span class="keyword">struct</span> SDVertex</div><div class="line">    &#123;</div><div class="line">        &lt;SDVertex Constructor <span class="number">152</span>&gt;</div><div class="line">        &lt;SDVertex Methods&gt;</div><div class="line">        Point P;</div><div class="line">        SDFace *startFace;</div><div class="line">        SDVertex *child;</div><div class="line">        <span class="keyword">bool</span> regular, boundary;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>SDVertex的构造器只做简单的初始化工作， 注意SDVertex::startFace的值被设为NULL。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;SDVertex Constructor&gt; ≡ <span class="number">152</span></div><div class="line">    SDVertex(Point pt = Point(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</div><div class="line">        : P(pt), startFace(<span class="literal">NULL</span>), child(<span class="literal">NULL</span>),</div><div class="line">    regular(<span class="literal">false</span>), boundary(<span class="literal">false</span>) &#123; &#125;</div></pre></td></tr></table></figure></p>
<p>网格的大部分拓扑信息存放在SDFace结构中。SDFace保存了指向三个顶点的指针和指向通过三个边与其相邻的三个面的指针。如果我们把从v[i]到v[(i+1)%3]的边标记为第i个边，那么该边所对应的邻接面应该是f[i]。这个索引方式极为重要，以后修正细分过的细分曲面的拓扑信息时，要用它来遍历整个网格。跟SDVertex相似，SDFace也存放指向下一级细分的子面的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;LoopSubdiv Local Structures&gt; +≡</div><div class="line">    <span class="keyword">struct</span> SDFace</div><div class="line">    &#123;</div><div class="line">        &lt;SDFace Constructor&gt;</div><div class="line">        &lt;SDFace Methods <span class="number">159</span>&gt;</div><div class="line">        SDVertex *v[<span class="number">3</span>];</div><div class="line">        SDFace *f[<span class="number">3</span>];</div><div class="line">        SDFace *children[<span class="number">4</span>];</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>辅助宏：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;LoopSubdiv Macros&gt; ≡</div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> NEXT(i) (((i)+1)%3)</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> PREV(i) (((i)+2)%3)</span></div></pre></td></tr></table></figure></p>
<p>LoopSubdiv要求网格是一致有序的，网格中的每个定向边只能出现一次，换言之，所有的面上的顶点次序都是一致的：要么都是逆时针，要么都是顺时针。莫比乌斯带是不被允许的。<br>有了以上的输入限制，构造函数开始初始化网格的拓扑数据结构。首先，遍历所有面，把它们的三个v指针指向对应的三个顶点。同时，也将每个顶点的SDVertex::startFace指针指向顶点的某一个邻接面。具体指向那个邻接面并不重要，所以每次遇到顶点的邻接面就把它赋值给startFace，这样就可以保证在循环结束后，所有的顶点都有某个非空的面指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;Set face to vertex pointers&gt; ≡ <span class="number">151</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *vp = vertexIndices;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfaces; ++i)</div><div class="line">    &#123;</div><div class="line">        SDFace *f = faces[i];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</div><div class="line">        &#123;</div><div class="line">            SDVertex *v = vertices[vp[j]];</div><div class="line">            f-&gt;v[j] = v;</div><div class="line">            v-&gt;startFace = f;</div><div class="line">        &#125;</div><div class="line">        vp += <span class="number">3</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>现在为每个面的f指针指向它所对应的邻接面。构造函数对所有的面进行遍历，为每条边创建一个SDEdge对象。当它遇到共享同一条边的另一个面时，就把两个面的邻接面指针指向对方。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;LoopSubdiv Local Structures&gt; +≡</div><div class="line">    <span class="keyword">struct</span> SDEdge</div><div class="line">    &#123;</div><div class="line">        &lt;SDEdge Constructor <span class="number">155</span>&gt;</div><div class="line">        &lt;SDEdge Comparison Function <span class="number">155</span>&gt;</div><div class="line">        SDVertex *v[<span class="number">2</span>];</div><div class="line">        SDFace *f[<span class="number">2</span>];</div><div class="line">        <span class="keyword">int</span> f0edgeNum;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>SDEdge构造函数的参数是边的两个顶点。它将两个顶点排序，使得先在内存出现的顶点放在v[0]。这段代码有些奇怪，但它基于指针也是可以象整数那样可以比较的事实。排序的目的是保证边（va，vb）跟边（vb，va）会被视为同一个边。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;SDEdge Constructor&gt; ≡ <span class="number">155</span></div><div class="line">    SDEdge(SDVertex *v0 = <span class="literal">NULL</span>, SDVertex *v1 = <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        v[<span class="number">0</span>] = min(v0, v1);</div><div class="line">        v[<span class="number">1</span>] = max(v0, v1);</div><div class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="literal">NULL</span>;</div><div class="line">        f0edgeNum = <span class="number">-1</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>该类也定义了对SDEdge对象排序的操作，用来保证它们在其它数据结构中以定义好的顺序排列。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;SDEdge Comparison Function&gt; ≡ <span class="number">155</span></div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> SDEdge &amp;e2) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (v[<span class="number">0</span>] == e2.v[<span class="number">0</span>])</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> v[<span class="number">1</span>] &lt; e2.v[<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> v[<span class="number">0</span>] &lt; e2.v[<span class="number">0</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>现在构造函数开始做遍历所有的面，在遍历过程中，设置每条边所对应的邻接面。它用了一个集合set来存放暂时只有一个邻接面的边。用set查找某条边的时间是O(log n)。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;Set neighbor pointers in faces&gt; ≡ <span class="number">151</span></div><div class="line">    <span class="built_in">set</span>&lt;SDEdge&gt; edges;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfaces; ++i)</div><div class="line">    &#123;</div><div class="line">        SDFace *f = faces[i];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> edgeNum = <span class="number">0</span>; edgeNum &lt; <span class="number">3</span>; ++edgeNum)</div><div class="line">        &#123;</div><div class="line">            &lt;Update neighbor pointer <span class="keyword">for</span> edgeNum <span class="number">156</span>&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对于每个面上的每条边，上面的循环体要创建一个SDEdge对象，看该边是否以前遇到过。如果是，则初始化和边对应的两个面的邻接面指针。否则，把它加入边的集合中。边的两个端点的索引值v0和v1，分别等于边索引值和边索引值加1。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;Update neighbor pointer <span class="keyword">for</span> edgeNum&gt; ≡ <span class="number">156</span></div><div class="line">    <span class="keyword">int</span> v0 = edgeNum, v1 = NEXT(edgeNum);</div><div class="line">    <span class="function">SDEdge <span class="title">e</span><span class="params">(f-&gt;v[v0], f-&gt;v[v1])</span></span>;</div><div class="line">    <span class="keyword">if</span> (edges.find(e) == edges.end())</div><div class="line">    &#123;</div><div class="line">        &lt;Handle <span class="keyword">new</span> edge <span class="number">156</span>&gt;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        &lt;Handle previously seen edge <span class="number">156</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果该边以前没有遇到过，就把指向当前面的指针放在边对象的f[0]中。由于网格是流形网格，最多还有一个面共享这条边。发现了这个面后，就可以初始化其邻接面的指针。把当前面的这条边的号码放在f0edgeNum中，这样它的邻接面就可以用这个号码初始化该面所对应的边的邻接面指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Handle <span class="keyword">new</span> edge&gt; ≡ <span class="number">156</span></div><div class="line">    e.f[<span class="number">0</span>] = f;</div><div class="line">    e.f0edgeNum = edgeNum;</div><div class="line">    edges.insert(e);</div></pre></td></tr></table></figure></p>
<p>当找到边的第二个面时，两个面的邻接面指针就可以设置为对方。这条边也可以被删除掉。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Handle previously seen edge&gt; ≡ <span class="number">156</span></div><div class="line">    e = *edges.find(e);</div><div class="line">    e.f[<span class="number">0</span>]-&gt;f[e.f0edgeNum] = f;</div><div class="line">    f-&gt;f[edgeNum] = e.f[<span class="number">0</span>];</div><div class="line">    edges.erase(e);</div></pre></td></tr></table></figure></p>
<p>执行到这里，每个面都指定了适当的邻接面指针，下一步是设置boundary和regular两个布尔值。为了确定一个顶点是否为边界点，需定义围绕顶点的面的次序：对于面f的顶点v，我们定义顶点的下一个面为与边（v[i]，v[NEXT(i)] ）相邻接的面，顶点的前一个面为与边（v[PREV(i)]，v[i]）相邻接的面。不断地从一个到下一个面即可遍历顶点的邻接面。如果遍历过程中回到出发的面，那么这个顶点即为内部顶点；如果途中遇到一个NULL指针，则可断定它是边界顶点。之后统计顶点的价，如果内部顶点的价为6或边界顶点的价为4，则为正规顶点，regular为真；否则，非正规顶点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;Finish vertex initialization&gt; ≡ <span class="number">151</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nvertices; ++i)</div><div class="line">    &#123;</div><div class="line">        SDVertex *v = vertices[i];</div><div class="line">        SDFace *f = v-&gt;startFace;</div><div class="line">        <span class="keyword">do</span></div><div class="line">        &#123;</div><div class="line">            f = f-&gt;nextFace(v);</div><div class="line">        &#125; <span class="keyword">while</span> (f &amp;&amp; f != v-&gt;startFace);</div><div class="line">        v-&gt;boundary = (f == <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">if</span> (!v-&gt;boundary &amp;&amp; v-&gt;valence() == <span class="number">6</span>)</div><div class="line">        &#123;</div><div class="line">            v-&gt;regular = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v-&gt;boundary &amp;&amp; v-&gt;valence() == <span class="number">4</span>)</div><div class="line">        &#123;</div><div class="line">            v-&gt;regular = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            v-&gt;regular = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>函数SDVertex::valence()提供了顶点价的计算。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;LoopSubdiv Inline Functions&gt; ≡</div><div class="line">    <span class="keyword">inline</span> <span class="keyword">int</span> SDVertex::valence()</div><div class="line">    &#123;</div><div class="line">        SDFace *f = startFace;</div><div class="line">        <span class="keyword">if</span> (!boundary)</div><div class="line">        &#123;</div><div class="line">            &lt;Compute valence of interior vertex <span class="number">158</span>&gt;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            &lt;Compute valence of boundary vertex <span class="number">159</span>&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>为了计算非边界顶点的价，函数计算该顶点的邻接面个数，方法是跟着每个面的下一个面的指针前进，直到抵达起始面为止，所遍历的面的个数就是顶点的价。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Compute valence of interior vertex&gt; ≡ <span class="number">158</span></div><div class="line">    <span class="keyword">int</span> nf = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> ((f = f-&gt;nextFace(<span class="keyword">this</span>)) != startFace)</div><div class="line">    &#123;</div><div class="line">        ++nf;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nf;</div></pre></td></tr></table></figure></p>
<p>对于边界顶点大致同理，但价是所遍历的面数加1。首先沿着下一个面的指针走直到遇到NULL为止；再从startFace开始沿着前一个面的指针走，直到遇到边界为止。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;Compute valence of boundary vertex&gt; ≡ <span class="number">158</span></div><div class="line">    <span class="keyword">int</span> nf = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> ((f = f-&gt;nextFace(<span class="keyword">this</span>)) != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        ++nf;</div><div class="line">    &#125;</div><div class="line">    f = startFace;</div><div class="line">    <span class="keyword">while</span> ((f = f-&gt;prevFace(<span class="keyword">this</span>)) != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        ++nf;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nf+<span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<p>SDFace::vnum()是一个返回顶点指针的索引值的辅助函数。如果传入一个不是该面的顶点指针，则会发生严重错误（Fatal Error，ヽ(*。&gt;Д&lt;)o゜）。这种情况常常表明其它部分代码出现了错误。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;SDFace Methods&gt; ≡ <span class="number">153</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">vnum</span><span class="params">(SDVertex *vert)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (v[i] == vert) <span class="keyword">return</span> i;</div><div class="line">            &#123;</div><div class="line">                Severe(<span class="string">"Basic logic error in SDFace::vnum()"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>因为面f上的顶点v[i]的下一个面过第i条边，我们可以用辅助函数vnum()很容易地得到下一个面的指针。同样地，前一个面过边（PREV(i)，i），用该函数也可以得到前一个面的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;SDFace Methods&gt; +≡ <span class="number">153</span></div><div class="line">    <span class="function">SDFace *<span class="title">nextFace</span><span class="params">(SDVertex *vert)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> f[vnum(vert)];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;SDFace Methods&gt; +≡ <span class="number">153</span></div><div class="line">    <span class="function">SDFace *<span class="title">prevFace</span><span class="params">(SDVertex *vert)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> f[PREV(vnum(vert))];</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>我们也需要知道从任意一个顶点出发绕着面的下一个顶点或前一个顶点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;SDFace Methods&gt; +≡ <span class="number">153</span></div><div class="line">    <span class="function">SDVertex *<span class="title">nextVert</span><span class="params">(SDVertex *vert)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> v[NEXT(vnum(vert))];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;SDFace Methods&gt; +≡ <span class="number">153</span></div><div class="line">    <span class="function">SDVertex *<span class="title">prevVert</span><span class="params">(SDVertex *vert)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> v[PREV(vnum(vert))];</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-7-2-边界"><a href="#3-7-2-边界" class="headerlink" title="3.7.2 边界"></a>3.7.2 边界</h3><p>Loop细分曲面具有凸包性（Convex Hull Property）：极限曲面被包含在原控制网格的凸包中。因此细分曲面的包围盒即为控制网格的包围盒，算法同TriangleMesh。</p>
<h3 id="3-7-3-细分"><a href="#3-7-3-细分" class="headerlink" title="3.7.3 细分"></a>3.7.3 细分</h3><p>LoopSubdiv本身不可求交。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;LoopSubdiv Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">bool</span> LoopSubdiv::CanIntersect() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Refine()函数处理所有的细分过程。LoopSubdiv完成细分后，生成代表曲面的TriangleMesh返回调用者。MemoryArena类提供了自定义的内存管理方式用于快速分配内存，自动释放。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;LoopSubdiv Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">void</span> LoopSubdiv::Refine(<span class="built_in">vector</span>&lt;Reference&lt;Shape&gt; &gt; &amp;refined) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;SDFace *&gt; f = faces;</div><div class="line">        <span class="built_in">vector</span>&lt;SDVertex *&gt; v = vertices;</div><div class="line">        MemoryArena arena;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLevels; ++i) </div><div class="line">        &#123;</div><div class="line">            &lt;Update f and v <span class="keyword">for</span> next level of subdivision <span class="number">161</span>&gt;</div><div class="line">        &#125;</div><div class="line">        &lt;Push vertices to limit surface <span class="number">171</span>&gt;</div><div class="line">        &lt;Compute vertex tangents on limit surface <span class="number">171</span>&gt;</div><div class="line">        &lt;Create TriangleMesh from subdivision mesh&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>细分过程的循环如下：为当前级的细分中所有的顶点和面创建vector，计算新的顶点位置，并更新细化网格的拓扑数据。细化规则：每个面被分成4个子面，使得第i个子面紧挨着第i个顶点，而且最后一个子面处在中间位置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Update f and v <span class="keyword">for</span> next level of subdivision&gt; ≡ <span class="number">161</span></div><div class="line">    <span class="built_in">vector</span>&lt;SDFace *&gt; newFaces;</div><div class="line">    <span class="built_in">vector</span>&lt;SDVertex *&gt; newVertices;</div><div class="line">    &lt;Allocate next level of children in mesh tree <span class="number">162</span>&gt;</div><div class="line">    &lt;Update vertex positions and create <span class="keyword">new</span> edge vertices <span class="number">162</span>&gt;</div><div class="line">    &lt;Update <span class="keyword">new</span> mesh topology <span class="number">169</span>&gt;</div><div class="line">    &lt;Prepare <span class="keyword">for</span> next level of subdivision <span class="number">170</span>&gt;</div></pre></td></tr></table></figure></p>
<p>首先，为已经在网格上存在的顶点申请内存空间，用于存放对原顶点的更改值。同时，还要为子面申请内存。需要初始化的工作很少，只有顶点的regular和boundary。细分发生后，原在边界上的顶点仍处于边界，在内部的顶点仍处于内部，且价不改变。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;Allocate next level of children in mesh tree&gt; ≡ <span class="number">161</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; v.size(); ++j)</div><div class="line">    &#123;</div><div class="line">        v[j]-&gt;child = arena.Alloc&lt;SDVertex&gt;();</div><div class="line">        v[j]-&gt;child-&gt;regular = v[j]-&gt;regular;</div><div class="line">        v[j]-&gt;child-&gt;boundary = v[j]-&gt;boundary;</div><div class="line">        newVertices.push_back(v[j]-&gt;child);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; f.size(); ++j)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</div><div class="line">        &#123;</div><div class="line">            f[j]-&gt;children[k] = arena.Alloc&lt;SDFace&gt;();</div><div class="line">            newFaces.push_back(f[j]-&gt;children[k]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-7-4-新顶点位置"><a href="#3-7-4-新顶点位置" class="headerlink" title="3.7.4 新顶点位置"></a>3.7.4 新顶点位置</h3><p>首先，计算已经在网格上的顶点的新位置，这些顶点被称为偶顶点（Even Vertices）。然后，再计算在边上的新顶点，这些顶点被称为奇顶点（Odd Vertices）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Update vertex positions and create <span class="keyword">new</span> edge vertices&gt; ≡ <span class="number">161</span></div><div class="line">    &lt;Update vertex positions <span class="keyword">for</span> even vertices <span class="number">162</span>&gt;</div><div class="line">    &lt;Compute <span class="keyword">new</span> odd edge vertices <span class="number">166</span>&gt;</div></pre></td></tr></table></figure></p>
<p>不同类型的偶顶点用不同的方法计算，分为正规的，非正规的，边界的，内部的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;Update vertex positions <span class="keyword">for</span> even vertices&gt; ≡ <span class="number">162</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; v.size(); ++j)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (!v[j]-&gt;boundary)</div><div class="line">        &#123;</div><div class="line">            &lt;Apply one-ring rule <span class="keyword">for</span> even vertex <span class="number">163</span>&gt;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">        &#123;</div><div class="line">            &lt;Apply boundary rule <span class="keyword">for</span> even vertex <span class="number">165</span>&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对于内部顶点，取与它相邻顶点的集合，赋予集合中每个顶点权值β，而内部顶点原位置赋予权值1-nβ。<br>$$v’=(1-n\beta)v+\sum_{i=1}^N\beta v_i$$<br>公式保证了权值的和是1，凸包性，局部支持性。β的取值是细分的关键，beta()函数用顶点的价来计算β值。对于正规的内部顶点，LoopSubdiv::beta()返回1/16。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;Apply one-ring rule <span class="keyword">for</span> even vertex&gt; ≡ <span class="number">162</span></div><div class="line">    <span class="keyword">if</span> (v[j]-&gt;regular)</div><div class="line">    &#123;</div><div class="line">        v[j]-&gt;child-&gt;P = weightOneRing(v[j], <span class="number">1.f</span>/<span class="number">16.f</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        v[j]-&gt;child-&gt;P = weightOneRing(v[j], beta(v[j]-&gt;valence()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;LoopSubdiv Private Methods&gt; ≡ <span class="number">151</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">beta</span><span class="params">(<span class="keyword">int</span> valence)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (valence == <span class="number">3</span>)</div><div class="line">        &#123;   </div><div class="line">            <span class="keyword">return</span> <span class="number">3.f</span>/<span class="number">16.f</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">3.f</span> / (<span class="number">8.f</span> * valence);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>LoopSubdiv::weightOneRing()函数遍历顶点的邻接点，使用相应的权值计算顶点的新位置。它调用SDVertex::oneRing()函数返回围绕着该顶点的邻接点的位置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;LoopSubdiv Method Definitions&gt; +≡</div><div class="line">    Point LoopSubdiv::weightOneRing(SDVertex *vert, <span class="keyword">float</span> beta)</div><div class="line">    &#123;</div><div class="line">        &lt;Put vert one-ring in Pring <span class="number">164</span>&gt;</div><div class="line">        Point P = (<span class="number">1</span> - valence * beta) * vert-&gt;P;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valence; ++i)</div><div class="line">        P += beta * Pring[i];</div><div class="line">        <span class="keyword">return</span> P;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>因为临界点数目可变，采用ALLOCA()宏有效分配内存空间。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Put vert one-ring in Pring&gt; ≡ <span class="number">164</span>, <span class="number">166</span></div><div class="line">    <span class="keyword">int</span> valence = vert-&gt;valence();</div><div class="line">    Point *Pring = ALLOCA(Point, valence);</div><div class="line">    vert-&gt;oneRing(Pring);</div></pre></td></tr></table></figure></p>
<p>oneRing()假定所传入的指针指向一个足够大的内存空间。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;LoopSubdiv Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">void</span> SDVertex::oneRing(Point *P)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (!boundary)</div><div class="line">        &#123;</div><div class="line">            Get one-ring vertices <span class="keyword">for</span> interior vertex <span class="number">164</span>&gt;</div><div class="line">        &#125;   </div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            &lt;Get one-ring vertices <span class="keyword">for</span> boundary vertex <span class="number">165</span>&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>遍历顶点相邻的面，取中心顶点在每个邻接面的下一个顶点，并放入集合中，得到内部顶点的邻接顶点环状集合。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Get one-ring vertices <span class="keyword">for</span> interior vertex&gt; ≡ <span class="number">164</span></div><div class="line">    SDFace *face = startFace;</div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">        *P++ = face-&gt;nextVert(<span class="keyword">this</span>)-&gt;P;</div><div class="line">        face = face-&gt;nextFace(<span class="keyword">this</span>);</div><div class="line">    &#125; <span class="keyword">while</span> (face != startFace);</div></pre></td></tr></table></figure></p>
<p>取边界顶点的邻接顶点环状集合要复杂一些。先将环状集合放在给定的Point数组中，使得首尾两个数组元素是边界上两个邻接的顶点。这个次序很重要，因为邻接的边界顶点跟那些邻接的内部顶点相比，常常有不同的权值。所以要先遍历邻接面，直到遇见边界上的面为止（这样做的目的是找到真正的遍历开始位置），再沿另一个方向遍历，把所找到的点一个个地存放到数组里。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;Get one-ring vertices <span class="keyword">for</span> boundary vertex&gt; ≡ <span class="number">164</span></div><div class="line">    SDFace *face = startFace, *f2;</div><div class="line">    <span class="keyword">while</span> ((f2 = face-&gt;nextFace(<span class="keyword">this</span>)) != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        face = f2;</div><div class="line">    &#125;</div><div class="line">    *P++ = face-&gt;nextVert(<span class="keyword">this</span>)-&gt;P;</div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">        *P++ = face-&gt;prevVert(<span class="keyword">this</span>)-&gt;P;</div><div class="line">        face = face-&gt;prevFace(<span class="keyword">this</span>);</div><div class="line">    &#125; <span class="keyword">while</span> (face != <span class="literal">NULL</span>);</div></pre></td></tr></table></figure></p>
<p>对于边界上的点，顶点的新位置是基于两个边界上的邻接顶点计算。新位置不依赖于内部顶点保证了对于在边界上共用顶点的两个相邻接的细分曲面，它们的极限曲面也是相邻接的。weightBoundary()辅助函数利用两个邻近顶点v1和v2的权值，计算出顶点的新位置v’，且边界上的点权重为1/8。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Apply boundary rule <span class="keyword">for</span> even vertex&gt; ≡ <span class="number">162</span></div><div class="line">    v[j]-&gt;child-&gt;P = weightBoundary(v[j], <span class="number">1.f</span>/<span class="number">8.f</span>);</div></pre></td></tr></table></figure></p>
<p>因为SDVertex::oneRing()把环状顶点集合的顶点排序，使得首尾两个数组元素是边界上两个邻接的顶点，这里的实现就变得容易。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;LoopSubdiv Method Definitions&gt; +≡</div><div class="line">    Point LoopSubdiv::weightBoundary(SDVertex *vert, <span class="keyword">float</span> beta)</div><div class="line">    &#123;</div><div class="line">        &lt;Put vert one-ring in Pring <span class="number">164</span>&gt;</div><div class="line">        Point P = (<span class="number">1</span><span class="number">-2</span>*beta) * vert-&gt;P;</div><div class="line">        P += beta * Pring[<span class="number">0</span>];</div><div class="line">        P += beta * Pring[valence<span class="number">-1</span>];</div><div class="line">        <span class="keyword">return</span> P;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>现在，是时候计算奇顶点的位置了。首先，遍历网格中的每个面上的每条边，计算把边截成两节的新顶点位置。对于内部边而言，取边的两个端点和与边相邻的两个面上的另外两个顶点，将这四个顶点的加权平均值作为新顶点。算法遍历每个面的三条边，每次发现一条新边，就为该边计算出新的奇顶点，再连同边一起存放关联数组edgeVerts中。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;Compute new odd edge vertices&gt; ≡ 162</div><div class="line">    map&lt;SDEdge, SDVertex *&gt; edgeVerts;</div><div class="line">    for (uint32_t j = 0; j &lt; f.size(); ++j)</div><div class="line">    &#123;</div><div class="line">        SDFace *face = f[j];</div><div class="line">        for (int k = 0; k &lt; 3; ++k)</div><div class="line">        &#123;</div><div class="line">            &lt;Compute odd vertex on kth edge 167&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Compute odd vertex on kth edge&gt; ≡ 166</div><div class="line">    SDEdge edge(face-&gt;v[k], face-&gt;v[NEXT(k)]);</div><div class="line">    SDVertex *vert = edgeVerts[edge];</div><div class="line">    if (!vert)</div><div class="line">    &#123;</div><div class="line">        &lt;Create and initialize new odd vertex 167&gt;</div><div class="line">        &lt;Apply edge rules to compute new vertex position 167&gt;</div><div class="line">        edgeVerts[edge] = vert;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在Loop细分算法中，新添加的顶点总是正规的（这意味着随着细分级数的增加，非正规顶点和正规顶点的比例也降低了），所以新顶点的regular被设为true。boundary值也很容易初始化：只需检查被打断的边是否有邻接面。另外，新顶点的startFace指针也在这里被设置好。对于一个面上的所有奇顶点而言，处于中间的子面（面号码为3）总是与新顶点相邻。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Create and initialize <span class="keyword">new</span> odd vertex&gt; ≡ <span class="number">167</span></div><div class="line">    vert = arena.Alloc&lt;SDVertex&gt;();</div><div class="line">    newVertices.push_back(vert);</div><div class="line">    vert-&gt;regular = <span class="literal">true</span>;</div><div class="line">    vert-&gt;boundary = (face-&gt;f[k] == <span class="literal">NULL</span>);</div><div class="line">    vert-&gt;startFace = face-&gt;children[<span class="number">3</span>];</div></pre></td></tr></table></figure></p>
<p>对于边界奇顶点而言，新顶点是两个相邻的顶点的平均值。对于内部奇顶点而言，边上的两个端点的权值设为3/8,其它两个顶点的权值设为1/8，SDFace::otherVert()辅助函数查找出这两个顶点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;Apply edge rules to compute <span class="keyword">new</span> vertex position&gt; ≡ <span class="number">167</span></div><div class="line">    <span class="keyword">if</span> (vert-&gt;boundary)</div><div class="line">    &#123;</div><div class="line">        vert-&gt;P = <span class="number">0.5f</span> * edge.v[<span class="number">0</span>]-&gt;P;</div><div class="line">        vert-&gt;P += <span class="number">0.5f</span> * edge.v[<span class="number">1</span>]-&gt;P;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        vert-&gt;P = <span class="number">3.f</span>/<span class="number">8.f</span> * edge.v[<span class="number">0</span>]-&gt;P;</div><div class="line">        vert-&gt;P += <span class="number">3.f</span>/<span class="number">8.f</span> * edge.v[<span class="number">1</span>]-&gt;P;</div><div class="line">        vert-&gt;P += <span class="number">1.f</span>/<span class="number">8.f</span> * face-&gt;otherVert(edge.v[<span class="number">0</span>], edge.v[<span class="number">1</span>])-&gt;P;</div><div class="line">        vert-&gt;P += <span class="number">1.f</span>/<span class="number">8.f</span> *</div><div class="line">        face-&gt;f[k]-&gt;otherVert(edge.v[<span class="number">0</span>], edge.v[<span class="number">1</span>])-&gt;P;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>SDFace::otherVert()函数，不言而喻。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;SDFace Methods&gt; +≡ <span class="number">153</span></div><div class="line">    <span class="function">SDVertex *<span class="title">otherVert</span><span class="params">(SDVertex *v0, SDVertex *v1)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (v[i] != v0 &amp;&amp; v[i] != v1)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> v[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Severe(<span class="string">"Basic logic error in SDVertex::otherVert()"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-7-5-修正网格拓扑"><a href="#3-7-5-修正网格拓扑" class="headerlink" title="3.7.5 修正网格拓扑"></a>3.7.5 修正网格拓扑</h3><p>为了修正细分过的网格的拓扑信息，有以下任务：</p>
<ul>
<li>奇顶点的SDVertex::startFace指针要指向它的邻接面之一</li>
<li>偶顶点的SDVertex::startFace指针同理</li>
<li>新面的邻接面指针f要设置为相应的邻接面</li>
<li>新面的v要设置为相应的顶点</li>
</ul>
<p>奇顶点的startFace指针已经在初始化时被设置好了，我们只需要处理其他三个任务。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Update <span class="keyword">new</span> mesh topology&gt; ≡ <span class="number">161</span></div><div class="line">    &lt;Update even vertex face pointers <span class="number">169</span>&gt;</div><div class="line">    &lt;Update face neighbor pointers <span class="number">169</span>&gt;</div><div class="line">    &lt;Update face vertex pointers <span class="number">170</span>&gt;</div></pre></td></tr></table></figure></p>
<p>如果顶点是其startFace的第i个顶点，那么可以保证它跟第i个子面的startFace邻接。所以，有必要遍历网格中所有的父顶点，对每个父顶点找到它在其startFace的顶点索引值。用这个索引值找到和新的偶顶点相邻的子面。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Update even vertex face pointers&gt; ≡ <span class="number">169</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; v.size(); ++j)</div><div class="line">    &#123;</div><div class="line">        SDVertex *vert = v[j];</div><div class="line">        <span class="keyword">int</span> vertNum = vert-&gt;startFace-&gt;vnum(vert);</div><div class="line">        vert-&gt;child-&gt;startFace =</div><div class="line">        vert-&gt;startFace-&gt;children[vertNum];</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>之后，修正新生成的面的邻接面指针。分两步进行：其一，修正同一父面的子面的邻接面指针；其二，修正不同父面的子面的邻接面指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;Update face neighbor pointers&gt; ≡ <span class="number">169</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; f.size(); ++j)</div><div class="line">    &#123;</div><div class="line">        SDFace *face = f[j];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</div><div class="line">        &#123;</div><div class="line">          &lt;Update children f pointers <span class="keyword">for</span> siblings <span class="number">169</span>&gt;</div><div class="line">          &lt;Update children f pointers <span class="keyword">for</span> neighbor children <span class="number">170</span>&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对于第一步，内部的子面存放在children[3]中。近一步地，第k+1个子面(k = 0,1,2)邻接内部子面的第k条边，而内部子面邻接第k个面的第k+1条边。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Update children f pointers <span class="keyword">for</span> siblings&gt; ≡ <span class="number">169</span></div><div class="line">    face-&gt;children[<span class="number">3</span>]-&gt;f[k] = face-&gt;children[NEXT(k)];</div><div class="line">    face-&gt;children[k]-&gt;f[NEXT(k)] = face-&gt;children[<span class="number">3</span>];</div></pre></td></tr></table></figure></p>
<p>现在要修正另一类子面的邻接指针，它们指向其它父面的子面。只考虑前三个子面，因为第四个已被初始化好。这里需要设置第k个子面的第k条边和第PREV(k)条边。为了设置k个子面的第k条边，要先找到父面的第k条边，然后找到共享这条边的（邻接子面的）父面f2。如果f2存在（表明它不在边界上），顶点v[k]的邻接子面的父面的索引值就被找到。这个索引值即为要找的邻接子面的索引值。这一方法同样适用于条边和第PREV(k)条边所对应的子面。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Update children f pointers <span class="keyword">for</span> neighbor children&gt; ≡ <span class="number">169</span></div><div class="line">    SDFace *f2 = face-&gt;f[k];</div><div class="line">    face-&gt;children[k]-&gt;f[k] = f2 ? f2-&gt;children[f2-&gt;vnum(face-&gt;v[k])] : <span class="literal">NULL</span>;</div><div class="line">    f2 = face-&gt;f[PREV(k)];</div><div class="line">    face-&gt;children[k]-&gt;f[PREV(k)] = f2 ? f2-&gt;children[f2-&gt;vnum(face-&gt;v[k])] : <span class="literal">NULL</span>;</div></pre></td></tr></table></figure></p>
<p>最后完成修正拓扑信息的第四部：设。置子面的顶点指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;Update face vertex pointers&gt; ≡ <span class="number">169</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; f.size(); ++j)</div><div class="line">    &#123;</div><div class="line">        SDFace *face = f[j];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</div><div class="line">        &#123;</div><div class="line">            &lt;Update child vertex pointer to <span class="keyword">new</span> even vertex <span class="number">170</span>&gt;</div><div class="line">            &lt;Update child vertex pointer to <span class="keyword">new</span> odd vertex <span class="number">170</span>&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对于第k个子面(k = 0,1,2)，第k的顶点对应于和该子面相邻接的偶顶点。非内部的子面有一个偶顶点和两个奇顶点；内部的子面有三个偶顶点。这个顶点是父顶点child指针所指的顶点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Update child vertex pointer to <span class="keyword">new</span> even vertex&gt; ≡ <span class="number">170</span></div><div class="line">    face-&gt;children[k]-&gt;v[k] = face-&gt;v[k]-&gt;child;</div></pre></td></tr></table></figure></p>
<p>为修正其余的顶点指针，又用到edgeVerts关联数组，用来寻找父面的每个边上的奇顶点。有三个子面共享该顶点，通过上图的编号规则，可以找到顶点在这三个子面中的索引值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Update child vertex pointer to <span class="keyword">new</span> odd vertex&gt; ≡ <span class="number">170</span></div><div class="line">    SDVertex *vert = edgeVerts[SDEdge(face-&gt;v[k], face-&gt;v[NEXT(k)])];</div><div class="line">    face-&gt;children[k]-&gt;v[NEXT(k)] = vert;</div><div class="line">    face-&gt;children[NEXT(k)]-&gt;v[k] = vert;</div><div class="line">    face-&gt;children[<span class="number">3</span>]-&gt;v[k] = vert;</div></pre></td></tr></table></figure></p>
<p>所有几何和拓扑方面的工作完成后，新创建的顶点和面被移到v和f数组。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Prepare <span class="keyword">for</span> next level of subdivision&gt; ≡ <span class="number">161</span></div><div class="line">    f = newFaces;</div><div class="line">    v = newVertices;</div></pre></td></tr></table></figure></p>
<h3 id="3-7-6-极限曲面的点与输出-P199"><a href="#3-7-6-极限曲面的点与输出-P199" class="headerlink" title="3.7.6 极限曲面的点与输出 P199"></a>3.7.6 极限曲面的点与输出 P199</h3><p>细分曲面的一个很好的性质就是有些特殊的细分规则可以给出极限曲面上的顶点。在这里使用这些规则来生成曲面上点的位置一个数组Plimit。在计算过程中把极限曲面上的点暂存在Plimit中而不是直接放在顶点数组，这一点很重要，因为每个顶点的极限曲面位置跟原顶点位置有关，所有顶点的原始位置在计算过程中不能改变。<br>对于边界顶点的极限规则是令相邻的两个顶点的权值为1/5，中心顶点的权值为3/5。内部顶点的极限规则是基于函数gamma()，它利用顶点的价来计算顶点适当的权值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;Push vertices to limit surface&gt; ≡ <span class="number">161</span></div><div class="line">    Point *Plimit = <span class="keyword">new</span> Point[v.size()];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; v.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (v[i]-&gt;boundary)</div><div class="line">        &#123;</div><div class="line">            Plimit[i] = weightBoundary(v[i], <span class="number">1.f</span>/<span class="number">5.f</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            Plimit[i] = weightOneRing(v[i], gamma(v[i]-&gt;valence()));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; v.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        v[i]-&gt;P = Plimit[i];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&lt;LoopSubdiv Private Methods&gt; +≡ <span class="number">151</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">gamma</span><span class="params">(<span class="keyword">int</span> valence)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1.f</span> / (valence + <span class="number">3.f</span> / (<span class="number">8.f</span> * beta(valence)));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>为了生成每个顶点带有曲面法向量的平滑的三角形网格，要在每个顶点上计算出两个极限曲面上的非平行的切向量。跟位置的极限规则相同，这里给出极限曲面上的精确的分析解。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;Compute vertex tangents on limit surface&gt; ≡ 161</div><div class="line">    vector&lt;Normal&gt; Ns;</div><div class="line">    Ns.reserve(v.size());</div><div class="line">    vector&lt;Point&gt; Pring(16, Point());</div><div class="line">    for (uint32_t i = 0; i &lt; v.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        SDVertex *vert = v[i];</div><div class="line">        Vector S(0,0,0), T(0,0,0);</div><div class="line">        int valence = vert-&gt;valence();</div><div class="line">        if (valence &gt; (int)Pring.size())</div><div class="line">        &#123;</div><div class="line">            Pring.resize(valence);</div><div class="line">        &#125;</div><div class="line">        vert-&gt;oneRing(&amp;Pring[0]);</div><div class="line">        if (!vert-&gt;boundary)</div><div class="line">        &#123;</div><div class="line">            &lt;Compute tangents of interior face 172&gt;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            &lt;Compute tangents of boundary face 173&gt;</div><div class="line">        &#125;</div><div class="line">        Ns.push_back(Normal(Cross(S, T)));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>中心的顶点的权值为零，相邻的顶点的权值设为wi。当计算第一个切向量s时，权值如下，n为顶点价。<br>$$w_i=\cos\frac{2\pi i}{n}$$<br>当求第二个切向量t时，权值如下。<br>$$w_i=\sin\frac{2\pi i}{n}$$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Compute tangents of interior face&gt; ≡ <span class="number">171</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; valence; ++k)</div><div class="line">    &#123;</div><div class="line">        S += cosf(<span class="number">2.f</span>*M_PI*k/valence) * Vector(Pring[k]);</div><div class="line">        T += sinf(<span class="number">2.f</span>*M_PI*k/valence) * Vector(Pring[k]);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>求在边界上的顶点切向量有些麻烦。第一个切向量，又称对角切向量(across tangent)，由v0和vn-1之间的向量给出。<br>$$s=v_{n-1}-v_0$$<br>第二个切向量，又称横向切向量(transverse tangent)，根据顶点的价计算。中心顶点的权值设为wc而环状顶点集合的权由一个向量（w0，w1，…， wn-1）给出。<br>| 价 |  wc  |  wi  |<br>|—-|:—-:|:—-:|<br>|2        |-2|（1，1）|<br>|3        |-1|（0，1，0）|<br>|4（正规）|-2|（-1，2，2，-1）|<br>对于大于等于5的价：<br>$$w_c=0\<br>w<em>0=w</em>{n-1}=\sin\theta\<br>w_i=(2\cos\theta -2)\sin(\theta i)\<br>\theta=\frac{\pi}{n-1}$$<br>这里没有给出证明：对于所有i的值，它们的权的总和为零。这就保证加权和为切向量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;Compute tangents of boundary face&gt; ≡ <span class="number">171</span></div><div class="line">    S = Pring[valence<span class="number">-1</span>] - Pring[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (valence == <span class="number">2</span>)</div><div class="line">    &#123;</div><div class="line">        T = Vector(Pring[<span class="number">0</span>] + Pring[<span class="number">1</span>] - <span class="number">2</span> * vert-&gt;P);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (valence == <span class="number">3</span>)</div><div class="line">    &#123;</div><div class="line">        T = Pring[<span class="number">1</span>] - vert-&gt;P;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (valence == <span class="number">4</span>) <span class="comment">// regular</span></div><div class="line">    &#123;</div><div class="line">        T = Vector(<span class="number">-1</span>*Pring[<span class="number">0</span>] + <span class="number">2</span>*Pring[<span class="number">1</span>] + <span class="number">2</span>*Pring[<span class="number">2</span>] +</div><div class="line">                   <span class="number">-1</span>*Pring[<span class="number">3</span>] + <span class="number">-2</span>*vert-&gt;P);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">float</span> theta = M_PI / <span class="keyword">float</span>(valence<span class="number">-1</span>);</div><div class="line">        T = Vector(sinf(theta) * (Pring[<span class="number">0</span>] + Pring[valence<span class="number">-1</span>]));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; valence<span class="number">-1</span>; ++k)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">float</span> wt = (<span class="number">2</span>*cosf(theta) - <span class="number">2</span>) * sinf((k) * theta);</div><div class="line">            T += Vector(wt * Pring[k]);</div><div class="line">        &#125;</div><div class="line">        T = -T;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>最后，片段<create trianglemesh="" from="" subdivision="" mesh="">创建一个三角形网格，并把它加入到LoopSubdiv::Refine()的变量refined中。这里不再赘述，因为这是很直接的从被细分的网格到TriangleMesh的转换。</create></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/CG/" rel="tag">#CG</a>
          
            <a href="/tags/PBRT/" rel="tag">#PBRT</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/14/pbrt-ch2/" rel="next" title="PBRT 章节2 几何与变换">
                <i class="fa fa-chevron-left"></i> PBRT 章节2 几何与变换
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Sulpures" />
          <p class="site-author-name" itemprop="name">Sulpures</p>
          <p class="site-description motion-element" itemprop="description">「今せぇいっぱい生きよう」</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-基本形体接口-P136"><span class="nav-number">1.</span> <span class="nav-text">3.1 基本形体接口 P136</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-边界"><span class="nav-number">1.1.</span> <span class="nav-text">3.1.1 边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-细化"><span class="nav-number">1.2.</span> <span class="nav-text">3.1.2 细化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-交点"><span class="nav-number">1.3.</span> <span class="nav-text">3.1.3 交点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-自相交的避免"><span class="nav-number">1.4.</span> <span class="nav-text">3.1.4 自相交的避免</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-5-几何着色"><span class="nav-number">1.5.</span> <span class="nav-text">3.1.5 几何着色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-6-表面面积"><span class="nav-number">1.6.</span> <span class="nav-text">3.1.6 表面面积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-7-片面性"><span class="nav-number">1.7.</span> <span class="nav-text">3.1.7 片面性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-球面-P142"><span class="nav-number">2.</span> <span class="nav-text">3.2 球面 P142</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-构造"><span class="nav-number">2.1.</span> <span class="nav-text">3.2.1 构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-边界"><span class="nav-number">2.2.</span> <span class="nav-text">3.2.2 边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-交点"><span class="nav-number">2.3.</span> <span class="nav-text">3.2.3 交点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-局部球面"><span class="nav-number">2.4.</span> <span class="nav-text">3.2.4 局部球面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-法线偏导数"><span class="nav-number">2.5.</span> <span class="nav-text">3.2.5 法线偏导数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-6-微分几何初始化"><span class="nav-number">2.6.</span> <span class="nav-text">3.2.6 微分几何初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-7-表面积"><span class="nav-number">2.7.</span> <span class="nav-text">3.2.7 表面积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-柱面-P153"><span class="nav-number">3.</span> <span class="nav-text">3.3 柱面 P153</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-构造"><span class="nav-number">3.1.</span> <span class="nav-text">3.3.1 构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-边界"><span class="nav-number">3.2.</span> <span class="nav-text">3.3.2 边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-交点"><span class="nav-number">3.3.</span> <span class="nav-text">3.3.3 交点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-局部柱面"><span class="nav-number">3.4.</span> <span class="nav-text">3.3.4 局部柱面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-5-表面积"><span class="nav-number">3.5.</span> <span class="nav-text">3.3.5 表面积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-圆盘-P158"><span class="nav-number">4.</span> <span class="nav-text">3.4 圆盘 P158</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-构造"><span class="nav-number">4.1.</span> <span class="nav-text">3.4.1 构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-边界"><span class="nav-number">4.2.</span> <span class="nav-text">3.4.2 边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-交点"><span class="nav-number">4.3.</span> <span class="nav-text">3.4.3 交点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4-表面积"><span class="nav-number">4.4.</span> <span class="nav-text">3.4.4 表面积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-其他二次曲线-P162"><span class="nav-number">5.</span> <span class="nav-text">3.5 其他二次曲线 P162</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-圆锥面"><span class="nav-number">5.1.</span> <span class="nav-text">3.5.1 圆锥面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-双曲面"><span class="nav-number">5.2.</span> <span class="nav-text">3.5.2 双曲面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-抛物面"><span class="nav-number">5.3.</span> <span class="nav-text">3.5.3 抛物面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-三角形与网格-P164"><span class="nav-number">6.</span> <span class="nav-text">3.6 三角形与网格 P164</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-三角形"><span class="nav-number">6.1.</span> <span class="nav-text">3.6.1 三角形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-三角形交点"><span class="nav-number">6.2.</span> <span class="nav-text">3.6.2 三角形交点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-3-表面积"><span class="nav-number">6.3.</span> <span class="nav-text">3.6.3 表面积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-4-着色几何"><span class="nav-number">6.4.</span> <span class="nav-text">3.6.4 着色几何</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-细分曲面-P177"><span class="nav-number">7.</span> <span class="nav-text">3.7 细分曲面 P177</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-1-网格的表示"><span class="nav-number">7.1.</span> <span class="nav-text">3.7.1 网格的表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-2-边界"><span class="nav-number">7.2.</span> <span class="nav-text">3.7.2 边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-3-细分"><span class="nav-number">7.3.</span> <span class="nav-text">3.7.3 细分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-4-新顶点位置"><span class="nav-number">7.4.</span> <span class="nav-text">3.7.4 新顶点位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-5-修正网格拓扑"><span class="nav-number">7.5.</span> <span class="nav-text">3.7.5 修正网格拓扑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-6-极限曲面的点与输出-P199"><span class="nav-number">7.6.</span> <span class="nav-text">3.7.6 极限曲面的点与输出 P199</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sulpures</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  

</body>
</html>

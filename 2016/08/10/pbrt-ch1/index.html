<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="CG,PBRT," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="1.1 文学编程 P30本书的全部伪代码由文学编程（Literate Program）的方式阐述。例，一段初始化全局变量的代码：1234567void InitGloabls(void)&amp;#123;    num_marbles = 25.7;    shoe_size = 13;    dielectric = true;    my_senator = REPUBLICAN;&amp;#125;
在文">
<meta property="og:type" content="article">
<meta property="og:title" content="PBRT 章节1 引言">
<meta property="og:url" content="http://sulpures.me/2016/08/10/pbrt-ch1/index.html">
<meta property="og:site_name" content="僕だけ居る">
<meta property="og:description" content="1.1 文学编程 P30本书的全部伪代码由文学编程（Literate Program）的方式阐述。例，一段初始化全局变量的代码：1234567void InitGloabls(void)&amp;#123;    num_marbles = 25.7;    shoe_size = 13;    dielectric = true;    my_senator = REPUBLICAN;&amp;#125;
在文">
<meta property="og:updated_time" content="2016-08-10T11:48:22.096Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PBRT 章节1 引言">
<meta name="twitter:description" content="1.1 文学编程 P30本书的全部伪代码由文学编程（Literate Program）的方式阐述。例，一段初始化全局变量的代码：1234567void InitGloabls(void)&amp;#123;    num_marbles = 25.7;    shoe_size = 13;    dielectric = true;    my_senator = REPUBLICAN;&amp;#125;
在文">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://sulpures.me/2016/08/10/pbrt-ch1/"/>

  <title> PBRT 章节1 引言 | 僕だけ居る </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">僕だけ居る</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                PBRT 章节1 引言
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-10T18:36:25+08:00" content="2016-08-10">
              2016-08-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Graphics/" itemprop="url" rel="index">
                    <span itemprop="name">Graphics</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-1-文学编程-P30"><a href="#1-1-文学编程-P30" class="headerlink" title="1.1 文学编程 P30"></a>1.1 文学编程 P30</h2><p>本书的全部伪代码由文学编程（Literate Program）的方式阐述。例，一段初始化全局变量的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitGloabls</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    num_marbles = <span class="number">25.7</span>;</div><div class="line">    shoe_size = <span class="number">13</span>;</div><div class="line">    dielectric = <span class="literal">true</span>;</div><div class="line">    my_senator = REPUBLICAN;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在文学编程中以如下形式表示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Function Definitions&gt; ≡</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitGloabls</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        &lt;Initialize Global Variables <span class="number">2</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如上所示，定义了一个片段（Fragment），名为<em>Function Definitions</em>，片段中包含了函数InitGloabls()的定义。函数内容引用了名为<em>Initialize Global Variables</em>的片段，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Initialize Global Variables&gt; ≡ <span class="number">2</span></div><div class="line">    shoe_size = <span class="number">13</span>;</div></pre></td></tr></table></figure></p>
<p>采用+≡符号为其添加内容，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Initialize Global Variables&gt; +≡ <span class="number">2</span></div><div class="line">    dielectric = <span class="literal">true</span>;</div></pre></td></tr></table></figure></p>
<h3 id="1-1-1-索引与交叉引用"><a href="#1-1-1-索引与交叉引用" class="headerlink" title="1.1.1 索引与交叉引用"></a>1.1.1 索引与交叉引用</h3><p>文学编程中，已定义的片段之后的数字表示其被引用的页码，当一个片段嵌于其他片段之内，它之后的数字表示该片段第一次定义时的页码。<br>如下为<em>Do something interesting</em>在500页被使用，而<em>Do something else interesting</em>在486页被定义。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Do something interesting&gt; +≡ <span class="number">500</span></div><div class="line">    InitializeSomethingInteresting();</div><div class="line">    &lt;Do something <span class="keyword">else</span> interesting <span class="number">486</span>&gt;</div><div class="line">    CleanUp();</div></pre></td></tr></table></figure></p>
<h2 id="1-2-真实感渲染与光线追踪算法-P33"><a href="#1-2-真实感渲染与光线追踪算法-P33" class="headerlink" title="1.2 真实感渲染与光线追踪算法 P33"></a>1.2 真实感渲染与光线追踪算法 P33</h2><p>真实感渲染的渲染系统大多基于光线追踪算法。所有的光追系统都要模拟以下的对象与现象：</p>
<ul>
<li>相机（Cameras）：决场景被观察的位置，产生从视点到场景的光线。</li>
<li>光物交点（Ray-object intersections）：光线与物体的交点位置，并需要知道交点特定的几何性质，如法线，材质。</li>
<li>光源分布（Light distribution）：光追模拟光在整个场景的分布，包括光源本身的位置和光照在空间内的能量分发等。</li>
<li>可见性（Visibility）：只有光线从光源到某点的路径不被遮挡，此点方可见。</li>
<li>表面散射（Surface scattering）：每个对象必须提供对其外观的描述，包括光与物体如何相互作用和光如何自然的散射等。表面散射模型通常是参数化的。</li>
<li>递归光追（Recursive ray tracing）：光与物体接触后，因折射或反射会产生额外的光线，继续追踪是必要的。</li>
<li>光线传播（Ray propagation）：需要关注光在传播途径中所经历的过程。从最典型的在真空中传播，到穿过烟、雾、大气等复杂情况。</li>
</ul>
<h3 id="1-2-1-相机"><a href="#1-2-1-相机" class="headerlink" title="1.2.1 相机"></a>1.2.1 相机</h3><p>现实世界中，能够拍摄物体的最简单的设备是针孔相机（pinhole camera）。在针孔相机中，只有位于可视空间（Viewing Volume）内的物体才可被成像。对于这个相机而言，图像上某一点的颜色值，只取决于穿过此点和针孔两点组成向量的光线。<br>因此，模拟相机的作用是得到图像上的点，并且生成和此点相关的光线。对于涉及多个镜头的复杂相机系统，计算与某一定点相关的光线时更为复杂。然而，如果将从图形位置转换到光线的处理完全封装于相机模块中，渲染系统的其余部分可以集中评估沿着那些光线的照明，并且可以支持各种不同的模拟相机。章节6会详细阐述PBRT的相机细节。</p>
<h3 id="1-2-2-光物交点"><a href="#1-2-2-光物交点" class="headerlink" title="1.2.2 光物交点"></a>1.2.2 光物交点</h3><p>每当相机生产出一条光线，首先要确定与光线相交的物体，以及交点的位置。这个交点，即为一个可视的点。寻找方式为将场景中的所有物体，和这条光线求交，之后选择出最近的那个点。给定一条光线r，其参数方程：<br>$$r(t) = o + td$$<br>代入表示物体表面的隐函数：<br>$$F(x,y,z) = 0$$<br>最后解t的方程即可。<br>这是一个极为暴力的方法，在场景复杂时计算代价极大。一个优化方式为建立加速结构（Acceleration Structure），快速剔除相交过程中不可能的对象组。借助特殊的数据结构，可将算法的时间优化成O（I log N）,其中I 为生成图像的像素个数，N为场景中物体的个数。当然，代价是昂贵的预处理和巨大内存使用，以及构建数据结构所消耗的O（N）。</p>
<h3 id="1-2-3-光源分布"><a href="#1-2-3-光源分布" class="headerlink" title="1.2.3 光源分布"></a>1.2.3 光源分布</h3><p>在求交阶段，我们可以得到交点中的某些几何信息。下一阶段，需要知道哪些光线到达了此点，这就涉及到了光在场景中的几何分布（Geometric）与辐射分布（Radiometric）。现世中，基于物理的光线一般为面光源（Area Light Sources），本章只讨论简单的点光源，更详细的光照分布将在章节5和章节12说明。<br>假设某点光源具有辐射功率（Power，即单位时间辐射的能量，又可称为辐射通量，Radiantflux）Φ且它的能量辐射向所有的方向，由此可知球体周围的总能量为<br>$$E = \frac{\Phi}{4\pi}$$<br>进一步，设有某微小表面片dA，且其法向量与该表面片到光源的方向夹角为θ，则可知在dA上所分布的全部微分辐照度（Differential Irradiance）为：<br>$$dE = \frac{\Phi \cos \theta}{4\pi r^2}$$<br>稍有常识的人都能看出<del>如果我们的坦克继续前进</del>，光在倾斜的表面上沿夹角的Cosine衰减，光在距离上沿平方的反比衰减。而处理多光源问题时，线性叠加即可。</p>
<h3 id="1-2-4-可见性"><a href="#1-2-4-可见性" class="headerlink" title="1.2.4 可见性"></a>1.2.4 可见性</h3><p>上文的描述，忽视了一个极为重要的因素，阴影（Shadows）。只有从光源到光物交点的路径不被遮挡时，光源才能对交点做出贡献。在光追中，利用阴影光线（Shadow Rays）判断点是否可见。阴影光线原点为表面上某被着色点，方向指向光源。在环境中追踪阴影光线，检查是否有与任意物体的交点存在与阴影光线之中。若存在，且交点到被着色点的距离小于被着色点到光源距离，则此被着色点不可见。</p>
<h3 id="1-2-5-表面散射"><a href="#1-2-5-表面散射" class="headerlink" title="1.2.5 表面散射"></a>1.2.5 表面散射</h3><p>在得到被着色点的位置和照射到该点的入射光信息后，现在探讨入射光在物体的表面上的分散，特别关心被着色点上进行散射，最终指向相机的那部分光。<br>场景中的每个物体都拥有其自己的材质（Material），描述了表面上每一点的外观特性。这个描述由双反射分布函数（BRDF，Bidirectional Reflectance Distribution Function）给出：<br>$$f_r(w_i, w_o) = \frac{dL_r(w_o)}{dE_i(w_i)} = \frac{dL_r(w_o)}{L_i(w_i)\cos\theta_i dw_i}$$<br>其中，ωi，ωo分别表示入射和出射光所占的立体角；Lr代表沿ωo发射出去的光能，即辐射增量；Ei代表延ωi入射的光能，即辐射度；θi是ωi和物体入射点上平面法线之间的夹角。BRDF的作用即为给定入射方向ωi和出射方向ωo，计算出多少光线能够被反射。下文伪代码用于计算光线L经过散射回到相机处的部分。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> each light:</div><div class="line">    <span class="keyword">if</span> light is not blocked:</div><div class="line">        incident_light = light.L(point)</div><div class="line">        amount_reflected = surface.BRDF(hit_point, camera_vector, light_vector)</div><div class="line">    L += amount_reflected * incident_light</div></pre></td></tr></table></figure></p>
<p>关于BRDF及其推广出的BTDF、BSDF将在章节8被详细说明。</p>
<h3 id="1-2-6-递归光追"><a href="#1-2-6-递归光追" class="headerlink" title="1.2.6 递归光追"></a>1.2.6 递归光追</h3><p>光线追踪的递归性与生俱来，早期论文甚至用其渲染高反射材质来炫技。物体到达相机处的光线往往是一些反射光、发射光、折射光的集合。渲染方程（Rendering Equation）可以将这一过程形式化：<br>$$L_o(p,w_o) = L_e(p,w<em>o) + \int</em>{g^2}f(p,w_o,w_i)L_i(p,w_i)|\cos\theta_i|dw_i$$<br>其中，Lo（p，ωo）为点p在ωo方向的出射光；Le（p，ωo）为物体本身在点p的ωo方向发出的光；Li（p，ωi）为点p在wi方向的入射光；积分表示在包围点p的球体上各个方向的入射光经计算得到的出射光的积分和。<br>除了极为简单的场景，完整计算此积分式是不可能的。一般讲，要根据渲染物体的性质进行选择性的简化或扩充。</p>
<h3 id="1-2-7-光线传播"><a href="#1-2-7-光线传播" class="headerlink" title="1.2.7 光线传播"></a>1.2.7 光线传播</h3><p>上述讨论，忽略了参与介质（Participating Media）对光线的影响。在光的传播过程中，参与介质有两种方式影响光的传输。其一，介质可以通过吸收或是反射的方式削弱光照。此时可以采用计算光源与交点之间的透射比（Transmittance）完成计算。透射比可以显示交点处多少光被散射回光源。其二，介质可以在光传播途中增强光照，此时可借助体积光运输方程（Volume Light Transport Equation）完成模拟。章节11与章节16将详细说明参与介质与体绘制。</p>
<h2 id="1-3-PBRT：系统概述-P44"><a href="#1-3-PBRT：系统概述-P44" class="headerlink" title="1.3 PBRT：系统概述 P44"></a>1.3 PBRT：系统概述 P44</h2><p>PBRT的结构采用标准的面向对象技术，系统提供了重要实体的抽象基类，使用者可以在此基础上派生。大多数系统的执行仅依靠这些抽象基类提供的接口完成，扩展性极强。其13个关键抽象基类见表。</p>
<h3 id="1-3-1-执行阶段"><a href="#1-3-1-执行阶段" class="headerlink" title="1.3.1 执行阶段"></a>1.3.1 执行阶段</h3><p>可分为两个阶段。阶段一，解析用户提供的场景。场景是包含了诸如几何形态、材质属性、灯光、相机等信息的文本文件。分析阶段会生成Scene类和Renderer类的实例，包含了场景中的内容，和渲染所需的算法。<br>一旦场景被指明，随即进入阶段二，主渲染循环。此步大量耗时，其具体实现位于Renderer::Render()中。</p>
<h3 id="1-3-2"><a href="#1-3-2" class="headerlink" title="1.3.2"></a>1.3.2</h3><p>PBRT的主函数位于main/pbrt.cpp中。首先遍历argv中的命令行参数，之后初始化Options结构体，储存参数中的文件名。options结构被传递至pbrtInit()中，之后对场景文件逐个渲染，最后调用pbrtCleanup()收尾。伪代码如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;main program&gt; ≡</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">    &#123;</div><div class="line">        Options options;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; filenames;</div><div class="line">        &lt;Process command-line arguments&gt;</div><div class="line">        pbrtInit(options);</div><div class="line">        &lt;Process scene description <span class="number">21</span>&gt;</div><div class="line">        pbrtCleanup();</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果PBRT运行时没有提供文件名，则从标准输入中读取文件信息。否则，将遍历提供的文件名，依次处理每个文件。伪代码如下，其中，“-”表示为标准输入，场景的解算过程由lex和yacc完成，书中没有详细解释，代码位于core/pbrtlex.ll和core/pbrtpares.yy中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Process scene description&gt; ≡ <span class="number">20</span></div><div class="line">    <span class="keyword">if</span> (filenames.size() == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        ParseFile(<span class="string">"-"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; filenames.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (!ParseFile(filenames[i]))</div><div class="line">            &#123;</div><div class="line">                Error(<span class="string">"Couldn’t open scene file \"%s\""</span>, filenames[i].c_str());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>以上，即为main/pbrt.cpp的全部。<br>场景被解算后，光照、几何基元等对象被RenderOptions::MakeScene()创建并储存与Scene类中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Scene Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> Scene</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;Scene Public Methods <span class="number">23</span>&gt;</div><div class="line">        &lt;Scene Public Data <span class="number">23</span>&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>场景中的每个几何对象都由一个基元（Primitive）表示。基元中含义两个对象，其一，形状（Shape），指定它的几何结构；其二，材质（Material），描述它的外观特质。场景中的基元被集中于场景的一个成员变量Scene::aggregate中。aggregate基元的集群，它只保持对其它各基元的引用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Scene Public Data&gt; ≡</div><div class="line">    Primitive *aggregate;</div></pre></td></tr></table></figure></p>
<p>场景中的每个光源都由一个光照对象（Light Object）来表示。它指定了光照的形状和能量分布，存储于vector之中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Scene Public Data&gt; +≡</div><div class="line">    <span class="built_in">vector</span>&lt;Light *&gt; lights;</div></pre></td></tr></table></figure></p>
<p>除了几何图元，PBRT也提供了参与介质和体积基元，通过VolumeRegion接口完成支持。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Scene Public Data&gt; +≡</div><div class="line">    VolumeRegion *volumeRegion;</div></pre></td></tr></table></figure></p>
<p>除了数据结构，Scene类也提供了一些函数。函数Intersect()可以用于判断指定光线是否和基元相交，并将最近的交点写入Intersection中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Scene Public Methods&gt; ≡ <span class="number">22</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Intersect</span><span class="params">(<span class="keyword">const</span> Ray &amp;ray, Intersection *isect)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">bool</span> hit = aggregate-&gt;Intersect(ray, isect);</div><div class="line">        <span class="keyword">return</span> hit;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>函数IntersectP()判断光线上是否存在交点，但不返回任何交点的信息。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Scene Public Methods&gt; +≡ <span class="number">22</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IntersectP</span><span class="params">(<span class="keyword">const</span> Ray &amp;ray)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">bool</span> hit = aggregate-&gt;IntersectP(ray);</div><div class="line">        <span class="keyword">return</span> hit;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>函数WorldBound()可以为几何结构创建三维结构的包围盒。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Scene Constructor Implementation&gt; ≡</div><div class="line">    bound = aggregate-&gt;WorldBound();</div><div class="line">    <span class="keyword">if</span> (volumeRegion)</div><div class="line">    &#123;</div><div class="line">        bound = Union(bound, volumeRegion-&gt;WorldBound());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Scene Public Data&gt; +≡ <span class="number">22</span></div><div class="line">    BBox bound;</div><div class="line"></div><div class="line">&lt;Scene Method Definitions&gt; ≡</div><div class="line">    <span class="keyword">const</span> BBox &amp;Scene::WorldBound() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">return</span> bound;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-3-3-渲染器接口与SamplerRenderer"><a href="#1-3-3-渲染器接口与SamplerRenderer" class="headerlink" title="1.3.3 渲染器接口与SamplerRenderer"></a>1.3.3 渲染器接口与SamplerRenderer</h3><p>对图形的渲染是由Renderer接口实现的。Renderer是一个含有各渲染器所必须的函数的抽象基类。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Renderer Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> Renderer </div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;Renderer Interface <span class="number">24</span>&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>Render()是渲染器必须提供的函数，它拥有指向Scene的指针并用于计算场景的图像。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Renderer Interface&gt; ≡ <span class="number">24</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Render</span><span class="params">(<span class="keyword">const</span> Scene *scene)</span> </span>= <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>渲染器也需要计算场景中光照信息的函数。Li()可以返回给定光线的辐射事件。其参数除光线和场景外，Sample提供了蒙特卡洛积分的随机样本值，RNG是伪随机数生成器，MemoryArena完成临时的内存分配，最后光线的几何交点被返回至Intersection，光线传播途中的容积率（Volumetric Transmittance）被存贮至Spectrum中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Renderer Interface&gt; +≡ <span class="number">24</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> Spectrum <span class="title">Li</span><span class="params">(<span class="keyword">const</span> Scene *scene, <span class="keyword">const</span> RayDifferential &amp;ray,</span></span></div><div class="line">                        <span class="keyword">const</span> Sample *sample, RNG &amp;rng, MemoryArena &amp;arena,</div><div class="line">                        Intersection *isect = <span class="literal">NULL</span>, Spectrum *T = <span class="literal">NULL</span>) <span class="keyword">const</span> = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>Transmittance()返回了在光线传播过程中因体积散射而衰减的部分。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Renderer Interface&gt; +≡ <span class="number">24</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> Spectrum <span class="title">Transmittance</span><span class="params">(<span class="keyword">const</span> Scene *scene,</span></span></div><div class="line">                                   <span class="keyword">const</span> RayDifferential &amp;ray, <span class="keyword">const</span> Sample *sample,</div><div class="line">                                   RNG &amp;rng, MemoryArena &amp;arena) <span class="keyword">const</span> = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>现在，可以依据渲染器接口来实现SamplerRenderer。这个渲染器的过程即为从采样器中获得大量采样数据，其每个采样对用图像中可以被光线照射到的像素点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;SamplerRenderer Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> SamplerRenderer : <span class="keyword">public</span> Renderer</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;SamplerRenderer Public Methods&gt;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        &lt;SamplerRenderer Private Data <span class="number">25</span>&gt;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>SamplerRenderer拥有指向Sampler的指针，采样器对生成图像的命运有很大的关系。其一，采样器负责选择图像平面上的点，用来生成被追踪的光线，其二，负责提供采样位置给积分器，用于光线传输过程的计算。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;SamplerRenderer Private Data&gt; ≡ <span class="number">25</span></div><div class="line">    Sampler *sampler;</div></pre></td></tr></table></figure></p>
<p>Camera对象控制了观察和透视的位置、方向、交点、视野等参数。成员变量Film位于其中，负责将结果写入磁盘。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;SamplerRenderer Private Data&gt; ≡ <span class="number">25</span></div><div class="line">    Camera *camera;</div></pre></td></tr></table></figure></p>
<p>积分器模拟光在场景中的传播并计算有多少光到达胶片的图像采样位置。之所以称之为积分器，是因为它用数值方法对表面上和体积上的光传输方程求积分。表面积分器计算从几何表面上的反射光，而体积积分器计算从体积体中散射出来的光。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;SamplerRenderer Private Data&gt; +≡ <span class="number">25</span></div><div class="line">    SurfaceIntegrator *surfaceIntegrator;</div><div class="line">    VolumeIntegrator *volumeIntegrator;</div></pre></td></tr></table></figure></p>
<p>SamplerRenderer的构造函数只是储存了成员变量的指针。当场景解析完毕，准备开始渲染时，pbrtWorldEnd()调用RenderOptions::MakeRenderer()，而后者创建了SamplerRenderer。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;SamplerRenderer Method Definitions&gt; ≡</div><div class="line">    SamplerRenderer::SamplerRenderer(Sampler *s, Camera *c,</div><div class="line">                                     SurfaceIntegrator *si, VolumeIntegrator *vi)</div><div class="line">    &#123;</div><div class="line">        sampler = s;</div><div class="line">        camera = c;</div><div class="line">        surfaceIntegrator = si;</div><div class="line">        volumeIntegrator = vi;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-3-4-主渲染循环"><a href="#1-3-4-主渲染循环" class="headerlink" title="1.3.4 主渲染循环"></a>1.3.4 主渲染循环</h3><p>当Scene和Renderer分配内存并初始化后，Renderer::Render()被调用，PBRT进入第二阶段：主渲染循环。Sampler为每个图像样本提供一系列的采样值，Camera将采样值转化为射入胶片平面的光线路径，之后积分器计算沿着光线路径进入胶片平面的光线辐射度，而积分得到的结果被Film收纳。这个过程将循环往复，直至Sampler提供了足以生成最终渲染结果的样本值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;SamplerRenderer Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">void</span> SamplerRenderer::Render(<span class="keyword">const</span> Scene *scene)</div><div class="line">    &#123;</div><div class="line">        &lt;Allow integrators to <span class="keyword">do</span> preprocessing <span class="keyword">for</span> the scene <span class="number">27</span>&gt;</div><div class="line">        &lt;Allocate and initialize sample <span class="number">27</span>&gt;</div><div class="line">        &lt;Create and launch SamplerRendererTasks <span class="keyword">for</span> rendering image <span class="number">28</span>&gt;</div><div class="line">        &lt;Clean up after rendering and store final image <span class="number">29</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在渲染开始前，渲染器调用Preprocess()函数为积分器进行预处理操作，使积分器能够处理场景中的光源或是几何体等信息。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Allow integrators to <span class="keyword">do</span> preprocessing <span class="keyword">for</span> the scene&gt; ≡ <span class="number">27</span></div><div class="line">    surfaceIntegrator-&gt;Preprocess(scene, camera, <span class="keyword">this</span>);</div><div class="line">    volumeIntegrator-&gt;Preprocess(scene, camera, <span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<p>同样在渲染开始前，调用Render()方法创建Sample对象，在主循环过程中储存采样结果。因为采样的数量和类型受到积分器的影响，因此构造函数中存在积分器的指针，以便响应需求。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Allocate and initialize sample&gt; ≡ <span class="number">27</span></div><div class="line">    Sample *sample = <span class="keyword">new</span> Sample(sampler, surfaceIntegrator,</div><div class="line">                                volumeIntegrator, scene);</div></pre></td></tr></table></figure></p>
<p>现在，主循环开始。渲染过程是多核并行完成的。例如，图形生成过程由一系列的SamplerRendererTask来完成，每个Task负责一小块矩形的渲染。Tasks之间相互独立，而Tasks的分解是PBRT并行的基础。函数EnqueueTasks()可以让tasks在所有的处理器中运行，并允许异步。而函数WaitForAllTasks()用于在渲染过程中等待所有的tasks执行完毕。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;Create and launch SamplerRendererTasks <span class="keyword">for</span> rendering image&gt; ≡ <span class="number">27</span></div><div class="line">    &lt;Compute number of SamplerRendererTasks to create <span class="keyword">for</span> rendering <span class="number">29</span>&gt;</div><div class="line">    <span class="built_in">vector</span>&lt;Task *&gt; renderTasks;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nTasks; ++i)</div><div class="line">    &#123;</div><div class="line">        renderTasks.push_back(<span class="keyword">new</span> SamplerRendererTask(scene, <span class="keyword">this</span>, camera,</div><div class="line">                              sampler, sample, nTasks<span class="number">-1</span>-i, nTasks));</div><div class="line">    &#125;</div><div class="line">    EnqueueTasks(renderTasks);</div><div class="line">    WaitForAllTasks();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; renderTasks.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">delete</span> renderTasks[i];</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>SamplerRendererTasks并非多多益善，需要权衡两件事：负载平衡（Load-balancing）与单任务开销（Per-task Overhead），但请尽量控制为2的整数幂。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Compute number of SamplerRendererTasks to create <span class="keyword">for</span> rendering&gt; ≡ <span class="number">28</span></div><div class="line">    <span class="keyword">int</span> nPixels = camera-&gt;film-&gt;xResolution * camera-&gt;film-&gt;yResolution;</div><div class="line">    <span class="keyword">int</span> nTasks = max(<span class="number">32</span> * NumSystemCores(), nPixels / (<span class="number">16</span>*<span class="number">16</span>));</div><div class="line">    nTasks = RoundUpPow2(nTasks);</div></pre></td></tr></table></figure></p>
<p>所有tasks执行完毕之后，回收内存，写入磁盘。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Clean up after rendering and store final image&gt; ≡ <span class="number">27</span></div><div class="line">    <span class="keyword">delete</span> sample;</div><div class="line">    camera-&gt;film-&gt;WriteImage();</div></pre></td></tr></table></figure></p>
<p>现在，讨论SamplerRendererTask的实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;SamplerRendererTask Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> SamplerRendererTask : <span class="keyword">public</span> Task</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;SamplerRendererTask Public Methods <span class="number">30</span>&gt;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        &lt;SamplerRendererTask Private Data <span class="number">30</span>&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>Task独立于SamplerRenderer::Render()而存在，其数据需要自己的构造函数进行赋值，当然，这些数据成员早已声明于类的成员变量中。此外，当前task编号与总task编号也是数据结构的一部分。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;SamplerRendererTask Public Methods&gt; ≡ <span class="number">29</span></div><div class="line">    SamplerRendererTask(<span class="keyword">const</span> Scene *sc, Renderer *ren, Camera *c,</div><div class="line">                        Sampler *ms, Sample *sam, <span class="keyword">int</span> tn, <span class="keyword">int</span> tc)</div><div class="line">    &#123;</div><div class="line">        scene = sc; renderer = ren; camera = c; mainSampler = ms;</div><div class="line">        origSample = sam; taskNum = tn; taskCount = tc;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&lt;SamplerRendererTask Private Data&gt; ≡ <span class="number">29</span></div><div class="line">    <span class="keyword">const</span> Scene *scene;</div><div class="line">    <span class="keyword">const</span> Renderer *renderer;</div><div class="line">    Camera *camera;</div><div class="line">    Sampler *mainSampler;</div><div class="line">    Sample *origSample;</div><div class="line">    <span class="keyword">int</span> taskNum, taskCount;</div></pre></td></tr></table></figure></p>
<p>当task已准备好在某处理器上运行时，调用SamplerRendererTask::Run()，选定负责的部分胶片平面，为临时数据分配内存，然后Camera、Sampler、Integrator按之前所述工作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;SamplerRendererTask Definitions&gt; ≡</div><div class="line">    <span class="keyword">void</span> SamplerRendererTask::Run()</div><div class="line">    &#123;</div><div class="line">        &lt;Get sub-Sampler <span class="keyword">for</span> SamplerRendererTask <span class="number">31</span>&gt;</div><div class="line">        &lt;Declare local variables used <span class="keyword">for</span> rendering loop <span class="number">31</span>&gt;</div><div class="line">        &lt;Allocate space <span class="keyword">for</span> samples and intersections <span class="number">31</span>&gt;</div><div class="line">        &lt;Get samples from Sampler and update image <span class="number">32</span>&gt;</div><div class="line">        &lt;Clean up after SamplerRendererTask is done with its image region&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当然，不同的task有其自己的采样器，负责其某一小矩形区域的采样，这由函数Sampler::<br>GetSubSampler()完成。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Get sub-Sampler <span class="keyword">for</span> SamplerRendererTask&gt; ≡ <span class="number">30</span></div><div class="line">    Sampler *sampler = mainSampler-&gt;GetSubSampler(taskNum, taskCount);</div><div class="line">    <span class="keyword">if</span> (!sampler)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在渲染过程中，函数Run()需要两个额外的局部变量：MemoryArena和RNG。前文已述，前者负责渲染过程中临时的内存管理，相比系统中日常的内存管理，MemoryArena具有性能优势，且简化了内存释放；后者为蒙特卡洛取样法提供伪随机数。二者都服务于积分器。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Declare local variables used <span class="keyword">for</span> rendering loop&gt; ≡ <span class="number">30</span></div><div class="line">    MemoryArena arena;</div><div class="line">    <span class="function">RNG <span class="title">rng</span><span class="params">(taskNum)</span></span>;</div></pre></td></tr></table></figure></p>
<p>对于某些采样生成算法，一次采样会生成多个样本值。函数Sampler::MaximumSampleCount()返回了采样数值的上限。对于每个样本，储存其匹配的光线于RayDifferential类中，存储器辐射率、透射比于Spectrum类中。上述分配的内存将在函数Render()中统一释放。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Allocate space <span class="keyword">for</span> samples and intersections&gt; ≡ <span class="number">30</span></div><div class="line">    <span class="keyword">int</span> maxSamples = sampler-&gt;MaximumSampleCount();</div><div class="line">    Sample *samples = origSample-&gt;Duplicate(maxSamples);</div><div class="line">    RayDifferential *rays = <span class="keyword">new</span> RayDifferential[maxSamples];</div><div class="line">    Spectrum *Ls = <span class="keyword">new</span> Spectrum[maxSamples];</div><div class="line">    Spectrum *Ts = <span class="keyword">new</span> Spectrum[maxSamples];</div><div class="line">    Intersection *isects = <span class="keyword">new</span> Intersection[maxSamples];</div></pre></td></tr></table></figure></p>
<p>每通过一次循环，函数Sampler::GetMoreSamples()被调用，以图像采样数据初始化样本数组。之后将匹配的相机光线送入积分器，最后累计样本对于最终成像结果的贡献，释放临时内存。由此可见，MemoryArena可防止循环过程中的内存泄漏。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Get samples from Sampler and update image&gt; ≡ <span class="number">30</span></div><div class="line">    <span class="keyword">int</span> sampleCount;</div><div class="line">    <span class="keyword">while</span> ((sampleCount = sampler-&gt;GetMoreSamples(samples, rng)) &gt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        &lt;Generate camera rays and compute radiance along rays <span class="number">32</span>&gt;</div><div class="line">        &lt;Report sample results to Sampler, add contributions to image <span class="number">33</span>&gt;</div><div class="line">        &lt;Free MemoryArena memory from computing image sample values <span class="number">33</span>&gt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Generate camera rays and compute radiance along rays&gt; ≡ <span class="number">32</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sampleCount; ++i)</div><div class="line">    &#123;</div><div class="line">        &lt;Find camera ray <span class="keyword">for</span> sample[i] <span class="number">32</span>&gt;</div><div class="line">        &lt;Evaluate radiance along camera ray <span class="number">33</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>相机接口提供了两个主要的方法。其一，Camera::GenerateRay()，返回图像采样的位置；其二，Camera::GenerateRayDifferential()，返回一个光线微分（Ray Differential），其中合并了光线的相关信息。光线微分用于纹理映射和抗锯齿等方向，在章节10有详细叙述。函数ScaleDifferentials()用于恢复密集采样时正常的样本间隔。<br>相机会返回一个浮点型光线权重值。复杂的相机系统，如透镜，可导致个别光线权重值大于其他。这个返回的权重值被用于按比例防缩图像中光线的贡献值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Find camera ray <span class="keyword">for</span> sample[i]&gt; ≡ <span class="number">32</span></div><div class="line">    <span class="keyword">float</span> rayWeight = camera-&gt;GenerateRayDifferential(samples[i], &amp;rays[i]);</div><div class="line">    rays[i].ScaleDifferentials(<span class="number">1.f</span> / sqrtf(sampler-&gt;samplesPerPixel));</div></pre></td></tr></table></figure></p>
<p>执行到这里，可以得到一条光线路径，下一步的任务是决定哪些光是沿着这条路径抵达像平面的，即辐射亮度。函数Renderer::Li()可完成辐射亮度的计算。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;Evaluate radiance along camera ray&gt; ≡ <span class="number">32</span></div><div class="line">    <span class="keyword">if</span> (rayWeight &gt; <span class="number">0.f</span>)</div><div class="line">    &#123;</div><div class="line">        Ls[i] = rayWeight * renderer-&gt;Li(scene, rays[i], &amp;samples[i], rng,</div><div class="line">                                         arena, &amp;isects[i], &amp;Ts[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> </div><div class="line">    &#123;</div><div class="line">        Ls[i] = <span class="number">0.f</span>;</div><div class="line">        Ts[i] = <span class="number">1.f</span>;</div><div class="line">    &#125;</div><div class="line">    &lt;Issue warning <span class="keyword">if</span> unexpected radiance value returned&gt;</div></pre></td></tr></table></figure></p>
<p>已知光线携带的辐射亮度后，函数Film::AddSample()会为图像更新信息。而在这之前，函数Sampler::ReportResults()已想图像中添加了含有其他信息的采样点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Report sample results to Sampler, add contributions to image&gt; ≡ <span class="number">32</span></div><div class="line">    <span class="keyword">if</span> (sampler-&gt;ReportResults(samples, rays, Ls, isects, sampleCount))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sampleCount; ++i)</div><div class="line">        &#123;</div><div class="line">            camera-&gt;film-&gt;AddSample(samples[i], Ls[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在一组采样值处理完毕后，释放内存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Free MemoryArena memory from computing image sample values&gt; ≡ <span class="number">32</span></div><div class="line">    arena.FreeAll();</div></pre></td></tr></table></figure></p>
<p>函数Scene::Intersect()返回光线与平面的第一个交点，储存于对象Intersection中。函数SamplerRenderer::Li()调用函数SurfaceIntegrator::Li()计算从此平面发出的光线的辐射亮度。之后，函数VolumeIntegrator::Transmittance()计算光在传输过程中因为参与介质而减损的部分。最终，函数VolumeIntegrator::Li()整合了参与介质的影响，返回最终的辐射亮度。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;SamplerRenderer Method Definitions&gt; +≡</div><div class="line">    Spectrum SamplerRenderer::Li(<span class="keyword">const</span> Scene *scene,</div><div class="line">             <span class="keyword">const</span> RayDifferential &amp;ray, <span class="keyword">const</span> Sample *sample, RNG &amp;rng,</div><div class="line">             MemoryArena &amp;arena, Intersection *isect, Spectrum *T) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        &lt;Allocate local variables <span class="keyword">for</span> isect and T <span class="keyword">if</span> needed <span class="number">35</span>&gt;</div><div class="line">        Spectrum Li = <span class="number">0.f</span>;</div><div class="line">        <span class="keyword">if</span> (scene-&gt;Intersect(ray, isect))</div><div class="line">        &#123;</div><div class="line">            Li = surfaceIntegrator-&gt;Li(scene, <span class="keyword">this</span>, ray, *isect, sample, rng, arena);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            &lt;Handle ray that doesn’t intersect any geometry <span class="number">35</span>&gt;</div><div class="line">        &#125;</div><div class="line">        Spectrum Lvi = volumeIntegrator-&gt;Li(scene, <span class="keyword">this</span>, ray, sample, rng, T, arena);</div><div class="line">        <span class="keyword">return</span> *T * Li + Lvi;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果访问者想置空isect和参数T，那么实例化这些类时可以在栈上分配内存，此时积分器便可假设对应的值非空。<del>这句话我没看懂</del><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;Allocate local variables <span class="keyword">for</span> isect and T <span class="keyword">if</span> needed&gt; ≡ <span class="number">34</span></div><div class="line">    Spectrum localT;</div><div class="line">    <span class="keyword">if</span> (!T)</div><div class="line">    &#123;</div><div class="line">        T = &amp;localT;</div><div class="line">    &#125;</div><div class="line">    Intersection localIsect;</div><div class="line">    <span class="keyword">if</span> (!isect)</div><div class="line">    &#123;</div><div class="line">        isect = &amp;localIsect;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>光线没有击中任何几何体，并不意味着它一定不贡献任何的辐射亮度。函数Light::Le()用于计算这些特殊光线的辐射亮度。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Handle ray that doesn’t intersect any geometry&gt; ≡ <span class="number">34</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; scene-&gt;lights.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        Li += scene-&gt;lights[i]-&gt;Le(ray);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>函数SamplerRenderer::Transmittance()通过调用VolumeIntegrator::Transmittance()完成独立的计算一条光线的衰减。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;SamplerRenderer Method Definitions&gt; +≡</div><div class="line">    Spectrum SamplerRenderer::Transmittance(<span class="keyword">const</span> Scene *scene,</div><div class="line">             <span class="keyword">const</span> RayDifferential &amp;ray, <span class="keyword">const</span> Sample *sample, RNG &amp;rng,</div><div class="line">             MemoryArena &amp;arena) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> volumeIntegrator-&gt;Transmittance(scene, <span class="keyword">this</span>, ray, sample, rng, arena);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-3-5-PBRT的并行"><a href="#1-3-5-PBRT的并行" class="headerlink" title="1.3.5 PBRT的并行"></a>1.3.5 PBRT的并行</h3><p>PBRT中，Mutex类提供了互斥锁，保证同一时间内只有一个线程得以访问共享内存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> globalCounter;</div><div class="line"><span class="keyword">extern</span> Mutex globalCounterMutex;</div><div class="line">&#123;</div><div class="line">    <span class="function">MutexLock <span class="title">lock</span><span class="params">(globalCounterMutex)</span></span>;</div><div class="line">    <span class="keyword">int</span> temp = globalCounter;</div><div class="line">    temp = temp - <span class="number">1</span>;</div><div class="line">    globalCounter = temp;</div><div class="line">    <span class="keyword">if</span> (globalCounter == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"done!\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述的自减运算，可使用函数AtomicAdd()使其成为原子操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> AtomicInt32 globalCounter;</div><div class="line"><span class="keyword">if</span> (AtomicAdd(&amp;globalCounter, <span class="number">-1</span>) == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"done!\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>PBRT采用上述两种方法处理并行问题，具体实例先按下不表。只要多个线程不指向同一数据，PBRT中所有的独立函数都是允许递归使用的。</p>
<h3 id="1-3-6-Whitted模型的光追积分器"><a href="#1-3-6-Whitted模型的光追积分器" class="headerlink" title="1.3.6 Whitted模型的光追积分器"></a>1.3.6 Whitted模型的光追积分器</h3><p>本章介绍基于Whitted模型光追算法的面积分器，可精确计算镜面材质的反射光和透射光，尽管它不支持间接照明的效果。WhittedIntegrator类被收录在integrators/whitted.h和integrators/whitted.cpp文件中。而更为复杂的表面积分器和体积积分器将在章节15和章节16详细阐述。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;WhittedIntegrator Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> WhittedIntegrator : <span class="keyword">public</span> SurfaceIntegrator</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;WhittedIntegrator Public Method&gt;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        &lt;WhittedIntegrator Private Data <span class="number">42</span>&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>面积分器的关键函数为SurfaceIntegrator::Li()，输入光的交点信息，返回沿光路下的辐射亮度。Whitted积分器的工作方式是沿着光线折射和反射的方向，递归的处理其辐射亮度。其递归的最大深度，在成员变量中声明。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;WhittedIntegrator Method Definitions&gt; ≡</div><div class="line">    Spectrum WhittedIntegrator::Li(<span class="keyword">const</span> Scene *scene,</div><div class="line">                                   <span class="keyword">const</span> Renderer *renderer, <span class="keyword">const</span> RayDifferential &amp;ray,</div><div class="line">                                   <span class="keyword">const</span> Intersection &amp;isect, <span class="keyword">const</span> Sample *sample, RNG                                        &amp;rng, MemoryArena &amp;arena) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="function">Spectrum <span class="title">L</span><span class="params">(<span class="number">0.</span>)</span></span>;</div><div class="line">        &lt;Evaluate BSDF at hit point <span class="number">43</span>&gt;</div><div class="line">        &lt;Initialize common variables <span class="keyword">for</span> Whitted integrator <span class="number">43</span>&gt;</div><div class="line">        &lt;Compute emitted light <span class="keyword">if</span> ray hit an area light source <span class="number">43</span>&gt;</div><div class="line">        &lt;Add contribution of each light source <span class="number">45</span>&gt;</div><div class="line">        <span class="keyword">if</span> (ray.depth + <span class="number">1</span> &lt; maxDepth)</div><div class="line">        &#123;</div><div class="line">            &lt;Trace rays <span class="keyword">for</span> specular reflection and refraction <span class="number">46</span>&gt;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> L;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>BSDF（= BRDF + BTDF）用于计算单一平面上的反射光。函数Intersection::GetBSDF()可获得交点处的BSDF。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Evaluate BSDF at hit point&gt; ≡ <span class="number">43</span></div><div class="line">BSDF *bsdf = isect.GetBSDF(ray, arena);</div></pre></td></tr></table></figure></p>
<p>当片选（Fragment）到来时，初始化交点p，法线n，指向相机的散射光线wo。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Initialize common variables <span class="keyword">for</span> Whitted integrator&gt; ≡ <span class="number">43</span></div><div class="line">    <span class="keyword">const</span> Point &amp;p = bsdf-&gt;dgShading.p;</div><div class="line">    <span class="keyword">const</span> Normal &amp;n = bsdf-&gt;dgShading.nn;</div><div class="line">    Vector wo = -ray.d;</div></pre></td></tr></table></figure></p>
<p>当交点位于的几何体本身是光源时，函数Intersection::Le()将自发光计算在内。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Compute emitted light <span class="keyword">if</span> ray hit an area light source&gt; ≡ <span class="number">43</span></div><div class="line">    L += isect.Le(wo);</div></pre></td></tr></table></figure></p>
<p>对于每条光线，积分器调用Light::Sample_L()函数计算落于被着色点平面上光线的辐射亮度，同时返回指向光源的方向向量，存储与wi中。此步不会考虑可见性问题，它返回一个VisibilityTester类，此类依靠阴影光线判断是否存在遮挡。如果到达该点的光辐射亮度非零，依据上文已经得到的两个角度wi、wo，代入BSDF，得到（wi，wo）角度下的贡献值。最后，积分器将输入光照辐射亮度乘上BSDF的结果、角度的cos以及光线与交点之间的透射比，得到最终反射的辐射亮度Lo。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;Add contribution of each light source&gt; ≡ <span class="number">43</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; scene-&gt;lights.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        Vector wi;</div><div class="line">        <span class="keyword">float</span> pdf;</div><div class="line">        VisibilityTester visibility;</div><div class="line">        Spectrum Li = scene-&gt;lights[i]-&gt;Sample_L(p, isect.rayEpsilon,</div><div class="line">        LightSample(rng), ray.time, &amp;wi, &amp;pdf, &amp;visibility);</div><div class="line">        <span class="keyword">if</span> (Li.IsBlack() || pdf == <span class="number">0.f</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        Spectrum f = bsdf-&gt;f(wo, wi);</div><div class="line">        <span class="keyword">if</span> (!f.IsBlack() &amp;&amp; visibility.Unoccluded(scene))</div><div class="line">        &#123;</div><div class="line">            L += f * Li * AbsDot(wi, n) *</div><div class="line">            visibility.Transmittance(scene, renderer, sample, rng, arena) / pdf;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>下一步，递归追踪。在SpecularReflect()和SpecularTransmit()两个函数中，对于给定的出射光和给定的散射方式，BSDF::Samplef()函数返回一个给定的入射方向，这是蒙特卡洛光传输算法的基础。而在这里，只是用它来寻找完美的反射和折射所对应的出射光，使用BSDF::Sample_f()函数来忽略掉不考虑的部分。此外，由于完美的反射和折射的方向固定，此时连随机性都不需要。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Trace rays <span class="keyword">for</span> specular reflection and refraction&gt; ≡ <span class="number">43</span>, <span class="number">789</span></div><div class="line">    L += SpecularReflect(ray, bsdf, rng, isect, renderer, scene, sample,</div><div class="line">                         arena);</div><div class="line">    L += SpecularTransmit(ray, bsdf, rng, isect, renderer, scene, sample,</div><div class="line">                          arena);</div></pre></td></tr></table></figure></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/CG/" rel="tag">#CG</a>
          
            <a href="/tags/PBRT/" rel="tag">#PBRT</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/10/pbrt-ch0/" rel="next" title="PBRT 学习笔记">
                <i class="fa fa-chevron-left"></i> PBRT 学习笔记
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/14/pbrt-ch2/" rel="prev" title="PBRT 章节2 几何与变换">
                PBRT 章节2 几何与变换 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Sulpures" />
          <p class="site-author-name" itemprop="name">Sulpures</p>
          <p class="site-description motion-element" itemprop="description">「今せぇいっぱい生きよう」</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-文学编程-P30"><span class="nav-number">1.</span> <span class="nav-text">1.1 文学编程 P30</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-索引与交叉引用"><span class="nav-number">1.1.</span> <span class="nav-text">1.1.1 索引与交叉引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-真实感渲染与光线追踪算法-P33"><span class="nav-number">2.</span> <span class="nav-text">1.2 真实感渲染与光线追踪算法 P33</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-相机"><span class="nav-number">2.1.</span> <span class="nav-text">1.2.1 相机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-光物交点"><span class="nav-number">2.2.</span> <span class="nav-text">1.2.2 光物交点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-光源分布"><span class="nav-number">2.3.</span> <span class="nav-text">1.2.3 光源分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4-可见性"><span class="nav-number">2.4.</span> <span class="nav-text">1.2.4 可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-5-表面散射"><span class="nav-number">2.5.</span> <span class="nav-text">1.2.5 表面散射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-6-递归光追"><span class="nav-number">2.6.</span> <span class="nav-text">1.2.6 递归光追</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-7-光线传播"><span class="nav-number">2.7.</span> <span class="nav-text">1.2.7 光线传播</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-PBRT：系统概述-P44"><span class="nav-number">3.</span> <span class="nav-text">1.3 PBRT：系统概述 P44</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-执行阶段"><span class="nav-number">3.1.</span> <span class="nav-text">1.3.1 执行阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2"><span class="nav-number">3.2.</span> <span class="nav-text">1.3.2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-渲染器接口与SamplerRenderer"><span class="nav-number">3.3.</span> <span class="nav-text">1.3.3 渲染器接口与SamplerRenderer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-4-主渲染循环"><span class="nav-number">3.4.</span> <span class="nav-text">1.3.4 主渲染循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-5-PBRT的并行"><span class="nav-number">3.5.</span> <span class="nav-text">1.3.5 PBRT的并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-6-Whitted模型的光追积分器"><span class="nav-number">3.6.</span> <span class="nav-text">1.3.6 Whitted模型的光追积分器</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sulpures</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  

</body>
</html>

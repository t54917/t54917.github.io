<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="CG,PBRT," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="上章的Shape类涵盖了物体对象的几何性质和抽象操作，但并不足矣完成对场景中物体的完全描述，比如，Shape类中缺少相应的材质信息，这将由本章的Primitive类补全。被用于渲染的形体由GeometricPrimitive类表示，此类联合了Shape类和Material类，最终达到分离几何部分与渲染部分。Material类详见章节9。TransformedPrimitive提供形体在场景中两种更">
<meta property="og:type" content="article">
<meta property="og:title" content="PBRT 章节4 图元与求交加速">
<meta property="og:url" content="http://sulpures.me/2016/08/30/pbrt-ch4/index.html">
<meta property="og:site_name" content="僕だけ居る">
<meta property="og:description" content="上章的Shape类涵盖了物体对象的几何性质和抽象操作，但并不足矣完成对场景中物体的完全描述，比如，Shape类中缺少相应的材质信息，这将由本章的Primitive类补全。被用于渲染的形体由GeometricPrimitive类表示，此类联合了Shape类和Material类，最终达到分离几何部分与渲染部分。Material类详见章节9。TransformedPrimitive提供形体在场景中两种更">
<meta property="og:updated_time" content="2016-08-30T09:06:31.892Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PBRT 章节4 图元与求交加速">
<meta name="twitter:description" content="上章的Shape类涵盖了物体对象的几何性质和抽象操作，但并不足矣完成对场景中物体的完全描述，比如，Shape类中缺少相应的材质信息，这将由本章的Primitive类补全。被用于渲染的形体由GeometricPrimitive类表示，此类联合了Shape类和Material类，最终达到分离几何部分与渲染部分。Material类详见章节9。TransformedPrimitive提供形体在场景中两种更">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://sulpures.me/2016/08/30/pbrt-ch4/"/>

  <title> PBRT 章节4 图元与求交加速 | 僕だけ居る </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">僕だけ居る</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                PBRT 章节4 图元与求交加速
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-30T17:06:17+08:00" content="2016-08-30">
              2016-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Graphics/" itemprop="url" rel="index">
                    <span itemprop="name">Graphics</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>上章的Shape类涵盖了物体对象的几何性质和抽象操作，但并不足矣完成对场景中物体的完全描述，比如，Shape类中缺少相应的材质信息，这将由本章的Primitive类补全。<br>被用于渲染的形体由GeometricPrimitive类表示，此类联合了Shape类和Material类，最终达到分离几何部分与渲染部分。Material类详见章节9。<br>TransformedPrimitive提供形体在场景中两种更普遍的用处：动画变换矩阵和对象实例，可以大幅度减少场景的内存需求。<br>本章还将介绍Aggregate基类，其是容纳若干Primitive的容器。PBRT用这个类来实现加速结构，它可以降低场景中物体和光线求交测试的复杂度。加速结构重用了Primitive接口，优点是PBRT可以支持混合形的加速方法，即一个类型的加速结构可以包含其它类型的加速结构。<br>本章介绍三种加速结构：GridAccel，基于一个覆盖场景的均匀网格；BVHAccel基于场景中包围盒的等级制度；KdTreeAccel,基于自适应递归式空间划分(Adaptive Recursive Spatial Subdivision)。</p>
<h2 id="4-1-图元接口与几何图元-P213"><a href="#4-1-图元接口与几何图元-P213" class="headerlink" title="4.1 图元接口与几何图元 P213"></a>4.1 图元接口与几何图元 P213</h2><p>Primitive类是连接几何阶段与着色阶段的桥梁，继承于ReferenceCounted。包含Primitive的其它类不应该存放Primitive的指针，而应存放Reference&lt;Primitive&gt;，以保证正确的引用计数。除此之外，Reference&lt;Primitive&gt;的其他行为与指针无二。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;Primitive Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> Primitive : <span class="keyword">public</span> ReferenceCounted</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;Primitive Interface <span class="number">185</span>&gt;</div><div class="line">        &lt;Primitive Public Data <span class="number">185</span>&gt;</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">        &lt;Primitive Protected Data <span class="number">185</span>&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>同形体，每个图元含有一个唯一的32位标识符，用于确定是哪一个实例。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;Primitive Interface&gt; ≡ <span class="number">185</span></div><div class="line">    Primitive() : primitiveId(nextprimitiveId++) &#123; &#125;</div><div class="line">    </div><div class="line">&lt;Primitive Public Data&gt; ≡ <span class="number">185</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> primitiveId;</div><div class="line"></div><div class="line">&lt;Primitive Protected Data&gt; ≡ <span class="number">185</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">uint32_t</span> nextprimitiveId;</div><div class="line"></div><div class="line">&lt;Primitive Method Definitions&gt; ≡</div><div class="line">    <span class="keyword">uint32_t</span> Primitive::nextprimitiveId = <span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<p>Primitive接口中含有5个几何例程。Primitive::WorldBound()返回了几何图元在世界空间下的包围盒。其余四个不言而喻。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Primitive Interface&gt; +≡ <span class="number">185</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> BBox <span class="title">WorldBound</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CanIntersect</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Intersect</span><span class="params">(<span class="keyword">const</span> Ray &amp;r, Intersection *in)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IntersectP</span><span class="params">(<span class="keyword">const</span> Ray &amp;r)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Refine</span><span class="params">(<span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; &amp;refined)</span> <span class="keyword">const</span></span>;</div></pre></td></tr></table></figure></p>
<p>注意，Primitive::Intersect()返回Intersection结构，而不是DifferentialGeometry，前者额外提供了交点的材质属性。此外，不同于Shape中的求交，这里要额外修改Ray::maxt。<br>Intersection存储了光与图元的交点信息，包括点在表面上的微分几何信息，指向Primitive的指针（说好的Reference&lt;&gt;呢……），以及一个W2O的变换。详见core/intersection.h和core/intersection.cpp。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;Intersection Declarations&gt; ≡</div><div class="line">    <span class="keyword">struct</span> Intersection</div><div class="line">    &#123;</div><div class="line">        &lt;Intersection Public Methods <span class="number">484</span>&gt;</div><div class="line">        &lt;Intersection Public Data <span class="number">186</span>&gt;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&lt;Intersection Public Data&gt; ≡ <span class="number">186</span></div><div class="line">    DifferentialGeometry dg;</div><div class="line">    <span class="keyword">const</span> Primitive *primitive;</div><div class="line">    Transform WorldToObject, ObjectToWorld;</div><div class="line">    <span class="keyword">uint32_t</span> shapeId, primitiveId;</div><div class="line">    <span class="keyword">float</span> rayEpsilon;</div></pre></td></tr></table></figure></p>
<p>有时需要反复提炼Primitive，以确保队列中所有的Primitive都是可求交的。函数FullyRefine()通过反复的调用Refine来完成。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;Primitive Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">void</span> Primitive::FullyRefine(<span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; &amp;refined) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; todo;</div><div class="line">        todo.push_back(<span class="keyword">const_cast</span>&lt;Primitive *&gt;(<span class="keyword">this</span>));</div><div class="line">        <span class="keyword">while</span> (todo.size())</div><div class="line">        &#123;</div><div class="line">            Reference&lt;Primitive&gt; prim = todo.back();</div><div class="line">            todo.pop_back();</div><div class="line">            <span class="keyword">if</span> (prim-&gt;CanIntersect())</div><div class="line">            &#123;</div><div class="line">                refined.push_back(prim);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                prim-&gt;Refine(todo);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Primitive含有3个依赖于材质属性的方法。其一，GetAreaLight()，当图元为光源时返回含有光照排放分布的AreaLight指针；其二，GetBSDF()，返回描述交点局部光照散射信息的BSDF对象；其三，:GetBSSRDF()，返回一个BSSRDF对象，用于描述图元内的光散射信息。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Primitive Interface&gt; +≡ <span class="number">185</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> AreaLight *<span class="title">GetAreaLight</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> BSDF *<span class="title">GetBSDF</span><span class="params">(<span class="keyword">const</span> DifferentialGeometry &amp;dg,</span></span></div><div class="line">        <span class="keyword">const</span> Transform &amp;ObjectToWorld, MemoryArena &amp;arena) <span class="keyword">const</span> = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> BSSRDF *<span class="title">GetBSSRDF</span><span class="params">(<span class="keyword">const</span> DifferentialGeometry &amp;dg,</span></span></div><div class="line">        <span class="keyword">const</span> Transform &amp;ObjectToWorld, MemoryArena &amp;arena) <span class="keyword">const</span> = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<h3 id="4-1-1-几何图元"><a href="#4-1-1-几何图元" class="headerlink" title="4.1.1 几何图元"></a>4.1.1 几何图元</h3><p>GeometricPrimitive类表示场景中的单个形体（如，一个球）。对于场景描述文件中的每个形体，都会被分配到一个GeometricPrimitive对象。详见core/primitive.h和core/primitive.cpp。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;GeometricPrimitive Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> GeometricPrimitive : <span class="keyword">public</span> Primitive</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;GeometricPrimitive Public Methods <span class="number">188</span>&gt;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        &lt;GeometricPrimitive Private Data <span class="number">188</span>&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>GeometricPrimitive包含有对形体和材质的引用，以及区域光的指针，如果图源充当光照的话。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;GeometricPrimitive Private Data&gt; ≡ <span class="number">187</span></div><div class="line">    Reference&lt;Shape&gt; shape;</div><div class="line">    Reference&lt;Material&gt; material;</div><div class="line">    AreaLight *areaLight;</div></pre></td></tr></table></figure></p>
<p>Primitive接口中和几何处理相关的大多数函数只是调用Shape中相应的函数而已。例，GeometricPrimitive::Intersect()调用Shape::Intersect()来做实际的几何求交运算，再用所得交点初始化Intersection对象，之后将最新的交点参数距离更新Ray::maxt，优点是如果发现图元处于光线范围之外，就不必进行求交测试。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;GeometricPrimitive Method Definitions&gt; ≡</div><div class="line">    <span class="keyword">bool</span> GeometricPrimitive::Intersect(<span class="keyword">const</span> Ray &amp;r,</div><div class="line">                                       Intersection *isect) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">float</span> thit, rayEpsilon;</div><div class="line">        <span class="keyword">if</span> (!shape-&gt;Intersect(r, &amp;thit, &amp;rayEpsilon, &amp;isect-&gt;dg))</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        isect-&gt;primitive = <span class="keyword">this</span>;</div><div class="line">        isect-&gt;WorldToObject = *shape-&gt;WorldToObject;</div><div class="line">        isect-&gt;ObjectToWorld = *shape-&gt;ObjectToWorld;</div><div class="line">        isect-&gt;shapeId = shape-&gt;shapeId;</div><div class="line">        isect-&gt;primitiveId = primitiveId;</div><div class="line">        isect-&gt;rayEpsilon = rayEpsilon;</div><div class="line">        r.maxt = thit;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>几何操作函数的实现大多同Shape类，不再赘述。至于材质操作，GetAreaLight()只是返回GeometricPrimitive::areaLight的成员，GetBSDF()从Primitive中取得着色几何信息并向Material类推送。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;GeometricPrimitive Method Definitions&gt; +≡</div><div class="line">    BSDF *GeometricPrimitive::GetBSDF(<span class="keyword">const</span> DifferentialGeometry &amp;dg,</div><div class="line">                                      <span class="keyword">const</span> Transform &amp;ObjectToWorld,</div><div class="line">                                      MemoryArena &amp;arena) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        DifferentialGeometry dgs;</div><div class="line">        shape-&gt;GetShadingGeometry(ObjectToWorld, dg, &amp;dgs);</div><div class="line">        <span class="keyword">return</span> material-&gt;GetBSDF(dg, dgs, arena);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-1-2-物体关联拷贝与动画图元"><a href="#4-1-2-物体关联拷贝与动画图元" class="headerlink" title="4.1.2 物体关联拷贝与动画图元"></a>4.1.2 物体关联拷贝与动画图元</h3><p>TransformedPrimitive类中含有一个Primitive和一个AnimatedTransform。额外的变换使它可以完成物体关联拷贝和图元的动画变换。<br>物体关联拷贝（Object Instancing）可以使一个图元通过变换出现在场景的多个位置中。回忆，Shapes通过O2W变换将物体对象安置到场景中。但，如果这个形体是由TransformedPrimitive举行，那么，这个形体概念上的世界空间并不是场景中真正的世界空间——只有当TransformedPrimitive提供的变换应用后，形体才被安置到真正的世界空间。<br>TransformedPrimitive的构造函数中含有一个图元的引用。如果几何体是被多个图元组合描述的，需要将图元储存到一个聚合体中（Aggregate）。此外TransformedPrimitive要求图元是可求交的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;TransformedPrimitive Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> TransformedPrimitive : <span class="keyword">public</span> Primitive</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;TransformedPrimitive Public Methods <span class="number">190</span>&gt;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        &lt;TransformedPrimitive Private Data <span class="number">190</span>&gt;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&lt;TransformedPrimitive Public Methods&gt; ≡ <span class="number">190</span></div><div class="line">    TransformedPrimitive(Reference&lt;Primitive&gt; &amp;prim,</div><div class="line">                         <span class="keyword">const</span> AnimatedTransform &amp;w2p)</div><div class="line">        : primitive(prim), WorldToPrimitive(w2p) &#123; &#125;</div><div class="line"></div><div class="line">&lt;TransformedPrimitive Private Data&gt; ≡ <span class="number">190</span></div><div class="line">    Reference&lt;Primitive&gt; primitive;</div><div class="line">    <span class="keyword">const</span> AnimatedTransform WorldToPrimitive;</div></pre></td></tr></table></figure></p>
<p>TransformedPrimitive的核心任务实现Primitived的接口，并负责使用它含有的变换矩阵。TransformedPrimitive中的WordToPrimitive变换定义了从世界到某特别几何实例坐标系的变换。Primitive成员中含有从TransformedPrimitive坐标系到对象空间的变换。二者组成了O2W。因此，TransformedPrimitive::Intersect()把给定的光线变换到图元坐标系中，并把被变换过的光线传给它的Intersect()求交。如果交点确定，被变换光线的maxt值需要被复制到最初被传送到Intersect()的光线r中，并且Intersection中的primitiveId需要用TransformedPrimitive中的图元编号重写（大雾，翻译的什么玩意）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;TransformedPrimitive Method Definitions&gt; ≡</div><div class="line">    <span class="keyword">bool</span> TransformedPrimitive::Intersect(<span class="keyword">const</span> Ray &amp;r,</div><div class="line">                                         Intersection *isect) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        Transform w2p;</div><div class="line">        WorldToPrimitive.Interpolate(r.time, &amp;w2p);</div><div class="line">        Ray ray = w2p(r);</div><div class="line">        <span class="keyword">if</span> (!primitive-&gt;Intersect(ray, isect))</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        r.maxt = ray.maxt;</div><div class="line">        isect-&gt;primitiveId = primitiveId;</div><div class="line">        <span class="keyword">if</span> (!w2p.IsIdentity())</div><div class="line">        &#123;</div><div class="line">            &lt;Compute world-to-object transformation <span class="keyword">for</span> instance <span class="number">191</span>&gt;</div><div class="line">            &lt;Transform instance’s differential geometry to world space <span class="number">191</span>&gt;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>前文已述，下文isect中的W2O实际上是伪世界空间到对象空间，实际上是P2O，右乘W2P补完（先A后B表示为BA）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Compute world-to-object transformation <span class="keyword">for</span> instance&gt; ≡ <span class="number">190</span></div><div class="line">    isect-&gt;WorldToObject = isect-&gt;WorldToObject * w2p;</div><div class="line">    isect-&gt;ObjectToWorld = Inverse(isect-&gt;WorldToObject);</div></pre></td></tr></table></figure></p>
<p>最后，将交点处的微分几何信息变换至世界空间下，Primitive成员中已经完成了O2P，因此只需补完P2W。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Transform instance’s differential geometry to world space&gt; ≡ <span class="number">190</span></div><div class="line">    Transform PrimitiveToWorld = Inverse(w2p);</div><div class="line">    isect-&gt;dg.p = PrimitiveToWorld(isect-&gt;dg.p);</div><div class="line">    isect-&gt;dg.nn = Normalize(PrimitiveToWorld(isect-&gt;dg.nn));</div><div class="line">    isect-&gt;dg.dpdu = PrimitiveToWorld(isect-&gt;dg.dpdu);</div><div class="line">    isect-&gt;dg.dpdv = PrimitiveToWorld(isect-&gt;dg.dpdv);</div><div class="line">    isect-&gt;dg.dndu = PrimitiveToWorld(isect-&gt;dg.dndu);</div><div class="line">    isect-&gt;dg.dndv = PrimitiveToWorld(isect-&gt;dg.dndv);</div></pre></td></tr></table></figure></p>
<p>Primitive剩下的操作是共享实例，结果同样需要被相应的TransformedPrimitive变换。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;TransformedPrimitive Public Methods&gt; +≡ <span class="number">190</span></div><div class="line">    <span class="function">BBox <span class="title">WorldBound</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> WorldToPrimitive.MotionBounds(primitive-&gt;WorldBound(), <span class="literal">true</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>那三个和材质相关的函数不应被调用。相反，只有和光线相交的图元才能够调用它们。对TransformedPrimitive的这些函数的调用会产生运行时错误。</p>
<h2 id="4-2-聚合体-P220"><a href="#4-2-聚合体-P220" class="headerlink" title="4.2 聚合体 P220"></a>4.2 聚合体 P220</h2><p>加速结构的意义是乘组的排除不想交的图元。广义的，有两种划分方式：空间划分和物体划分。GridAccel和KdTreeAccel基于前者，BVHAccel基于后者。Aggregate类提供了将Primitive对象合并的接口。因为Aggregate本身实现了Primitive接口，因此不需要为加速提供特殊的支持。为了实现新的加速技术，只需写一个新的Aggregate图元，并添加到PBRT中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Aggregate Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> Aggregate : <span class="keyword">public</span> Primitive</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;Aggregate Public Methods&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>如同TransformedPrimitive类似，Aggregate求交例程中留下Intersection::primitive的指针，指向实际跟光线相交的那个图元，而不是包含那个图元的聚合体。为此PBRT用这个指针取得交点上的信息（如反射性质、发射光性质等），而绝对不能调用Aggregate中所继承的那3个材质过程函数。</p>
<h3 id="4-2-1-光盒交点"><a href="#4-2-1-光盒交点" class="headerlink" title="4.2.1 光盒交点"></a>4.2.1 光盒交点</h3><p>下述所有加速结构都拥有包围盒。包围盒可以理解为三个平板的交集，其中两个平板相平行，第三个平板构成了平行空间的中间区域。某些加速结构对光与包围盒的两个交点值敏感，引入BBox::IntersectP()返回t值。注意区间[Ray::mint, Ray::maxt]。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;BBox Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">bool</span> BBox::IntersectP(<span class="keyword">const</span> Ray &amp;ray, <span class="keyword">float</span> *hitt0,</div><div class="line">                          <span class="keyword">float</span> *hitt1) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">float</span> t0 = ray.mint, t1 = ray.maxt;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            &lt;Update interval <span class="keyword">for</span> ith bounding box slab <span class="number">195</span>&gt;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (hitt0)</div><div class="line">        &#123;</div><div class="line">            *hitt0 = t0;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (hitt1)</div><div class="line">        &#123;</div><div class="line">            *hitt1 = t1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>光线o+td与面ax+by+cz+d=0求交。注意两个d是不同的。<br>$$t=\frac{-d-(\vec{o}·(a,b,c))}{(\vec{d}·(a,b,c))}$$<br>不要忘记这里的盒子是和坐标轴平行的。对于沿x轴的平板，a=1且b=c=0且系数d=-x1。因此：<br>$$t_1=\frac{x_1-\vec{o_x}}{\vec{d_x}}$$<br>实现代码。没有必要做非零判定。如果它为零，invRayDir将是无穷，仍正常工作（IEEE 1985）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Update interval <span class="keyword">for</span> ith bounding box slab&gt; ≡ <span class="number">194</span></div><div class="line">    <span class="keyword">float</span> invRayDir = <span class="number">1.f</span> / ray.d[i];</div><div class="line">    <span class="keyword">float</span> tNear = (pMin[i] - ray.o[i]) * invRayDir;</div><div class="line">    <span class="keyword">float</span> tFar = (pMax[i] - ray.o[i]) * invRayDir;</div><div class="line">    &lt;Update parametric interval from slab intersection t s <span class="number">195</span>&gt;</div></pre></td></tr></table></figure></p>
<p>更新参数区间。注意，如果光的原点在包围盒的平板上光线与平板平面重合，那么tNear或tFar有可能被计算为0/0的形式，即NaN，而任何跟NaN相关的逻辑比较都返回false。因此，更改t0和t1的数据时要尽量避免tNear和tFar被处理为为NaN，此时t0和t1的区间范围将永远得不到改变。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;Update parametric interval from slab intersection t s&gt; ≡ <span class="number">195</span></div><div class="line">    <span class="keyword">if</span> (tNear &gt; tFar)</div><div class="line">    &#123;</div><div class="line">        swap(tNear, tFar);</div><div class="line">    &#125;</div><div class="line">    t0 = tNear &gt; t0 ? tNear : t0;</div><div class="line">    t1 = tFar &lt; t1 ? tFar : t1;</div><div class="line">    <span class="keyword">if</span> (t0 &gt; t1)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-3-网格加速结构-P224"><a href="#4-3-网格加速结构-P224" class="headerlink" title="4.3 网格加速结构 P224"></a>4.3 网格加速结构 P224</h2><p>GridAccel将轴对齐的空间区域划分成大小相同的体元(Voxel)。每个体元存有和它重叠的图元的引用。给定一条光线，加速器按光线穿过的每个体元的先后次序进行交点测试，而且只和体元中记录的图元进行测试。GridAccel的初始化很快，决定沿光线的图元测试次序也容易确定，但也注定了它的适应性很差。详见accelerators/grid.h和accelerators/grid.cpp。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;GridAccel Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> GridAccel : <span class="keyword">public</span> Aggregate</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;GridAccel Public Methods <span class="number">208</span>&gt;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        &lt;GridAccel Private Methods <span class="number">200</span>&gt;</div><div class="line">        &lt;GridAccel Private Data <span class="number">198</span>&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<h3 id="4-3-1-创建"><a href="#4-3-1-创建" class="headerlink" title="4.3.1 创建"></a>4.3.1 创建</h3><p>构造函数使用vector来存储网格中的Primitive。它根据图元的个数自动决定体元的个数。对于网格的实现，注意有些图元不能直接求交，当建立网格时这些图元会带来问题：也许场景中只有几个不可求交的图元，为此算法将场景粗略分成几个图元，然，当细分图元时，不可求交图元会被细分为上百万个可求交图元，此时加速结构几乎毫无用处。为此，两种解决方式：</p>
<ul>
<li>网格构造器中refineImmediately标志为真，所有的不可求交图元会被细分为可求交图元。这也许很浪费资源，因为有些图元根本没必要细分，因为没有光线跟它们相交。 </li>
<li>否则，只有当光线进入图元所重叠的体元时才细化图元。如果细化出多个图元，新图元被放入一个新的GridAccel实例中并取代顶级网格中细化前的图元。其目的在于每次细化一个图元不必重建整个网格。</li>
</ul>
<p>图元细化可能会造成多线程问题：当一个线程遍历网格时，另一个线程在修改网格中的共享数据。。下文中会解决这个问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;GridAccel Method Definitions&gt; ≡</div><div class="line">    GridAccel::GridAccel(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; &amp;p,</div><div class="line">                         <span class="keyword">bool</span> refineImmediately)</div><div class="line">    &#123;</div><div class="line">        &lt;Initialize primitives with primitives <span class="keyword">for</span> grid <span class="number">198</span>&gt;</div><div class="line">        &lt;Compute bounds and choose grid resolution <span class="number">198</span>&gt;</div><div class="line">        &lt;Compute voxel widths and allocate voxels <span class="number">199</span>&gt;</div><div class="line">        &lt;Add primitives to grid voxels <span class="number">199</span>&gt;</div><div class="line">        &lt;Create reader-writer mutex <span class="keyword">for</span> grid <span class="number">205</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先，判断是直接将图元存储，还是在这之前保证所有图元可求交。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Initialize primitives with primitives <span class="keyword">for</span> grid&gt; ≡ <span class="number">197</span></div><div class="line">    <span class="keyword">if</span> (refineImmediately)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; p.size(); ++i)</div><div class="line">        &#123;</div><div class="line">            p[i]-&gt;FullyRefine(primitives);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        primitives = p;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;GridAccel Private Data&gt; ≡ <span class="number">196</span></div><div class="line">    <span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; primitives;</div></pre></td></tr></table></figure></p>
<p>构造函数下一步要做的工作是计算涵盖所有图元的包围盒，并决定沿坐标轴划分多少个体元。变量voxelPerUnitDist给出一般条件下沿三个轴方向单位长度上的体元数。这个值乘每个方向上的包围盒长度，即得到该方向上的体元数。然，上限是64，避免复杂场景下的数据结构过于庞大。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;Compute bounds and choose grid resolution&gt; ≡ <span class="number">197</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; primitives.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        bounds = Union(bounds, primitives[i]-&gt;WorldBound());</div><div class="line">    &#125;</div><div class="line">    Vector delta = bounds.pMax - bounds.pMin;</div><div class="line">    &lt;Find voxelsPerUnitDist <span class="keyword">for</span> grid <span class="number">199</span>&gt;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> axis = <span class="number">0</span>; axis &lt; <span class="number">3</span>; ++axis)</div><div class="line">    &#123;</div><div class="line">        nVoxels[axis] = Round2Int(delta[axis] * voxelsPerUnitDist);</div><div class="line">        nVoxels[axis] = Clamp(nVoxels[axis], <span class="number">1</span>, <span class="number">64</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;GridAccel Private Data&gt; +≡ <span class="number">196</span></div><div class="line">    <span class="keyword">int</span> nVoxels[<span class="number">3</span>];</div><div class="line">    BBox bounds;</div></pre></td></tr></table></figure></p>
<p>估算网格的大小的第一步，应保证体元总数与图元总数大致成正比。如果图元均匀分布，那么每个体元中图元的数应大致相等。为达到这个正比，取图元个数的立方根再乘某个常数，PBRT的常数是3。也就是说，对于N个图元的场景，令包围盒最长的一侧有$3\sqrt[3]{N}$个体元，另两轴的设置要保证体元是大致的立方体。voxelsPerUnit它决定了单位距离上的体元个数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Find voxelsPerUnitDist <span class="keyword">for</span> grid&gt; ≡ <span class="number">198</span></div><div class="line">    <span class="keyword">int</span> maxAxis = bounds.MaximumExtent();</div><div class="line">    <span class="keyword">float</span> invMaxWidth = <span class="number">1.f</span> / delta[maxAxis];</div><div class="line">    <span class="keyword">float</span> cubeRoot = <span class="number">3.f</span> * powf(<span class="keyword">float</span>(primitives.size()), <span class="number">1.f</span>/<span class="number">3.f</span>);</div><div class="line">    <span class="keyword">float</span> voxelsPerUnitDist = cubeRoot * invMaxWidth;</div></pre></td></tr></table></figure></p>
<p>每个坐标轴的体元确定后，构造函数调用GridAccel::Width设置体元在世界空间内的宽度，并计算出它的倒数GridAccel::InvWidth。最后，为网格中每个体元申请指向Voxel结构的指针，这些指针初始化为NULL，只有一个或多个体素跟它重叠时，才会申请空间。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;Compute voxel widths and allocate voxels&gt; ≡ <span class="number">197</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> axis = <span class="number">0</span>; axis &lt; <span class="number">3</span>; ++axis)</div><div class="line">    &#123;</div><div class="line">        width[axis] = delta[axis] / nVoxels[axis];</div><div class="line">        invWidth[axis] = (width[axis] == <span class="number">0.f</span>) ? <span class="number">0.f</span> : <span class="number">1.f</span> / width[axis];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> nv = nVoxels[<span class="number">0</span>] * nVoxels[<span class="number">1</span>] * nVoxels[<span class="number">2</span>];</div><div class="line">    voxels = AllocAligned&lt;Voxel *&gt;(nv);</div><div class="line">    <span class="built_in">memset</span>(voxels, <span class="number">0</span>, nv * <span class="keyword">sizeof</span>(Voxel *));</div><div class="line"></div><div class="line">&lt;GridAccel Private Data&gt; +≡ <span class="number">196</span></div><div class="line">    Vector width, invWidth;</div><div class="line">    Voxel **voxels;</div></pre></td></tr></table></figure></p>
<p>体元被分配内存后，就可以加入图元。GridAccel构造函数向体元中添加了每个图元对应的Primitive指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Add primitives to grid voxels&gt; ≡ <span class="number">197</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; primitives.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        &lt;Find voxel extent of primitive <span class="number">200</span>&gt;</div><div class="line">        &lt;Add primitive to overlapping voxels <span class="number">200</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先，我们把图元的世界空间下的包围盒转换成包含两个对角的整形体元坐标。GridAccel::PosToVoxel()函数完成这个工作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;GridAccel Private Methods&gt; ≡ <span class="number">196</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">posToVoxel</span><span class="params">(<span class="keyword">const</span> Point &amp;P, <span class="keyword">int</span> axis)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> v = Float2Int((P[axis] - bounds.pMin[axis]) * invWidth[axis]);</div><div class="line">        <span class="keyword">return</span> Clamp(v, <span class="number">0</span>, nVoxels[axis]<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Find voxel extent of primitive&gt; ≡ <span class="number">199</span></div><div class="line">    BBox pb = primitives[i]-&gt;WorldBound();</div><div class="line">    <span class="keyword">int</span> vmin[<span class="number">3</span>], vmax[<span class="number">3</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> axis = <span class="number">0</span>; axis &lt; <span class="number">3</span>; ++axis)</div><div class="line">    &#123;</div><div class="line">        vmin[axis] = posToVoxel(pb.pMin, axis);</div><div class="line">        vmax[axis] = posToVoxel(pb.pMax, axis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>GridAccel::VoxelToPos()函数与GridAccel::PosVoxel()函数相反，它返回体元的下角的坐标。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;GridAccel Private Methods&gt; +≡ <span class="number">196</span></div><div class="line">    <span class="function"><span class="keyword">float</span> <span class="title">voxelToPos</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> axis)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> bounds.pMin[axis] + p * width[axis];</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>现在可以将图元加入到与它包围盒重叠的体元中。使用包围盒的重叠测试是保守测试，容易高估了重叠体元个数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;Add primitive to overlapping voxels&gt; ≡ <span class="number">199</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> z = vmin[<span class="number">2</span>]; z &lt;= vmax[<span class="number">2</span>]; ++z)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = vmin[<span class="number">1</span>]; y &lt;= vmax[<span class="number">1</span>]; ++y)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = vmin[<span class="number">0</span>]; x &lt;= vmax[<span class="number">0</span>]; ++x)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> o = offset(x, y, z);</div><div class="line">                <span class="keyword">if</span> (!voxels[o])</div><div class="line">                &#123;</div><div class="line">                    &lt;Allocate <span class="keyword">new</span> voxel and store primitive in it <span class="number">201</span>&gt;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    &lt;Add primitive to already-allocated voxel <span class="number">201</span>&gt;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>GridAccel::Offset()辅助函数给出特定体元在体元数组的偏置值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;GridAccel Private Methods&gt; +≡ <span class="number">196</span></div><div class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">offset</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> z*nVoxels[<span class="number">0</span>]*nVoxels[<span class="number">1</span>] + y*nVoxels[<span class="number">0</span>] + x;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>为进一步减少体元动态申请的内存并改进它的内存位置，网格的构造函数使用MemoryArena为体元提供内存，它提供了基于大块内存的内存分配例程。它并不为每次的内存分配释放内存，而是一次把所有内存释放掉。这样做会减少开销。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Allocate <span class="keyword">new</span> voxel and store primitive in it&gt; ≡ <span class="number">200</span></div><div class="line">    voxels[o] = voxelArena.Alloc&lt;Voxel&gt;();</div><div class="line">    *voxels[o] = Voxel(primitives[i]);</div><div class="line"></div><div class="line">&lt;GridAccel Private Data&gt; +≡ <span class="number">196</span></div><div class="line">    MemoryArena voxelArena;</div></pre></td></tr></table></figure></p>
<p>如果这不是第一个覆盖该体元的图元，那么该Voxel已被分配内存，直接调用Voxel::AddPrimitive()将图元并入。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Add primitive to already-allocated voxel&gt; ≡ <span class="number">200</span></div><div class="line">    voxels[o]-&gt;AddPrimitive(primitives[i]);</div></pre></td></tr></table></figure></p>
<p>Voxel结构使用vector记录哪些体素与它的区域重叠。Voxel::allCanIntersect成员记录了是否体元内所有图元可求交。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Voxel Declarations&gt; ≡</div><div class="line">    <span class="keyword">struct</span> Voxel</div><div class="line">    &#123;</div><div class="line">        &lt;Voxel Public Methods <span class="number">202</span>&gt;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; primitives;</div><div class="line">        <span class="keyword">bool</span> allCanIntersect;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>当一个Voxel第一次被创建，一个单一的图元被送入构造函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;Voxel Public Methods&gt; ≡ <span class="number">202</span></div><div class="line">    Voxel(Reference&lt;Primitive&gt; op)</div><div class="line">    &#123;</div><div class="line">        allCanIntersect = <span class="literal">false</span>;</div><div class="line">        primitives.push_back(op);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Voxel Public Methods&gt; +≡ <span class="number">202</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddPrimitive</span><span class="params">(Reference&lt;Primitive&gt; prim)</span></span></div><div class="line">    &#123;</div><div class="line">        primitives.push_back(prim);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-3-2-遍历"><a href="#4-3-2-遍历" class="headerlink" title="4.3.2 遍历"></a>4.3.2 遍历</h3><p>GridAccel::Intersect()函数确定光线穿过的体元并调用相应求交函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;GridAccel Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">bool</span> GridAccel::Intersect(<span class="keyword">const</span> Ray &amp;ray, Intersection *isect) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        &lt;Check ray against overall grid bounds <span class="number">203</span>&gt;</div><div class="line">        &lt;Set up <span class="number">3</span>DDDA <span class="keyword">for</span> ray <span class="number">204</span>&gt;</div><div class="line">        &lt;Walk ray through voxel grid <span class="number">205</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先确定光线是在哪里进入网格以得到体元遍历的起始位置。如果光线原点在网格的包围盒之内，显然，它的起始位置就在这里。否则，GridAccel::Intersect()函数寻找光线与网格包围盒的交点， 如果光线击中包围盒，最近交点为起始点；如果没有击中，那就没有咯。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;Check ray against overall grid bounds&gt; ≡ <span class="number">202</span></div><div class="line">    <span class="keyword">float</span> rayT;</div><div class="line">    <span class="keyword">if</span> (bounds.Inside(ray(ray.mint)))</div><div class="line">    &#123;</div><div class="line">        rayT = ray.mint;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!bounds.IntersectP(ray, &amp;rayT))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    Point gridIntersect = ray(rayT);</div></pre></td></tr></table></figure></p>
<p>求交函数之后计算该光线的起始位置的整形体元坐标和其它几个用来帮助体元遍历的辅助值。光线-体元遍历算法实质上与Bresenham直线算法相同，这类算法被称为数字微分分析法（Digital Differential Analyzer，DDA）。在遍历算法中，需要关注以下变量：</p>
<ul>
<li>当前正在被考虑的体元坐标Pos</li>
<li>光线在xyz三个方向上和下一个体元相交的参数t值NextCrossT</li>
<li>进行下一步后当前体元的坐标在每个方向上的变化（1或-1）值Step</li>
<li>光线在每个方向上沿光线方向走一个体元的参数距离DeltaT</li>
<li>光线走出网格时的最后一个体元的坐标Out</li>
</ul>
<p>前两项变量要在每一步体元遍历时修改，而后三项对每条光线而言是不变的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Set up <span class="number">3</span>DDDA <span class="keyword">for</span> ray&gt; ≡ <span class="number">202</span></div><div class="line">    <span class="keyword">float</span> NextCrossingT[<span class="number">3</span>], DeltaT[<span class="number">3</span>];</div><div class="line">    <span class="keyword">int</span> Step[<span class="number">3</span>], Out[<span class="number">3</span>], Pos[<span class="number">3</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> axis = <span class="number">0</span>; axis &lt; <span class="number">3</span>; ++axis)</div><div class="line">    &#123;</div><div class="line">        &lt;Compute current voxel <span class="keyword">for</span> axis <span class="number">204</span>&gt;</div><div class="line">        <span class="keyword">if</span> (ray.d[axis] &gt;= <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            &lt;Handle ray with positive direction <span class="keyword">for</span> voxel stepping <span class="number">204</span>&gt;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            &lt;Handle ray with negative direction <span class="keyword">for</span> voxel stepping <span class="number">205</span>&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>调用GridAccel::PosToVoxel()得到开始的体元地址。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Compute current voxel <span class="keyword">for</span> axis&gt; ≡ <span class="number">204</span></div><div class="line">    Pos[axis] = posToVoxel(gridIntersect, axis);</div></pre></td></tr></table></figure></p>
<p>如果光线的某方向的分量为0，那么下面所列出的计算把NextCrossingT在该轴上的值初始化为IEEE浮点无穷大，体元遍历中要保证不沿这个方向进行下去。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Handle ray with positive direction <span class="keyword">for</span> voxel stepping&gt; ≡ <span class="number">204</span></div><div class="line">    NextCrossingT[axis] = rayT + (voxelToPos(Pos[axis]+<span class="number">1</span>, axis) </div><div class="line">                               - gridIntersect[axis]) / ray.d[axis];</div><div class="line">    DeltaT[axis] = width[axis] / ray.d[axis];</div><div class="line">    Step[axis] = <span class="number">1</span>;</div><div class="line">    Out[axis] = nVoxels[axis];</div></pre></td></tr></table></figure></p>
<p>类似地，可以求出当光线方向分量为负值的这些值，区别只是将DeltaT取反，Step和Out取-1。<br>所有的预处理工作完成，逐个遍历网格。从第一个体元开始，求交函数检车体元内的图元和光线的交点。在光遍历网格时，GridAccel中读写互斥锁保证了同一时间内只有一个线程可修改共享数据且此时数据不可读。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Create reader-writer mutex <span class="keyword">for</span> grid&gt; ≡ <span class="number">197</span></div><div class="line">    rwMutex = RWMutex::Create();</div><div class="line"></div><div class="line">&lt;GridAccel Private Data&gt; +≡ <span class="number">196</span></div><div class="line">    <span class="keyword">mutable</span> RWMutex *rwMutex;</div></pre></td></tr></table></figure></p>
<p>从第一个体元开始，求交函数检查体元内图元和光线的交点。如果有交点，则设置hitSomething为真，考虑到图元可能和多个体元重叠，此时交点可能在当前体元之外。为此当找到一个交点后，函数并不马上返回，而是利用图元求交函数会修改光线的Ray::maxt的这个事实——因此只有当光线进入一个体元的进入点比最近交点还要远才返回。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;Walk ray through voxel grid&gt; ≡ <span class="number">202</span></div><div class="line">    <span class="function">RWMutexLock <span class="title">lock</span><span class="params">(*rwMutex, READ)</span></span>;</div><div class="line">    <span class="keyword">bool</span> hitSomething = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (;;)</div><div class="line">    &#123;</div><div class="line">        &lt;Check <span class="keyword">for</span> intersection in current voxel and advance to next <span class="number">205</span>&gt;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hitSomething;</div><div class="line">    </div><div class="line">&lt;Check <span class="keyword">for</span> intersection in current voxel and advance to next&gt; ≡ <span class="number">205</span></div><div class="line">    Voxel *voxel = voxels[offset(Pos[<span class="number">0</span>], Pos[<span class="number">1</span>], Pos[<span class="number">2</span>])];</div><div class="line">    <span class="keyword">if</span> (voxel != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        hitSomething |= voxel-&gt;Intersect(ray, isect, lock);</div><div class="line">    &#125;</div><div class="line">    &lt;Advance to next voxel <span class="number">207</span>&gt;</div></pre></td></tr></table></figure></p>
<p>对于每个非空体元，函数调用Voxel的Intersect()。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;GridAccel Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">bool</span> Voxel::Intersect(<span class="keyword">const</span> Ray &amp;ray, Intersection *isect,</div><div class="line">                          RWMutexLock &amp;lock)</div><div class="line">    &#123;</div><div class="line">        &lt;Refine primitives in voxel <span class="keyword">if</span> needed <span class="number">206</span>&gt;</div><div class="line">        &lt;Loop over primitives in voxel and find intersections <span class="number">207</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Voxel::allCanIntersect布尔成员变量用来表明是否所有的图元可求交。如果该值为false，Intersect()必须遍历全部图元找出不可求交的图元并细化至可求交为止。注意，此步也涉及到公共数据的修改，因此注意线程安全。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;Refine primitives in voxel <span class="keyword">if</span> needed&gt; ≡ <span class="number">206</span></div><div class="line">    <span class="keyword">if</span> (!allCanIntersect)</div><div class="line">    &#123;</div><div class="line">        lock.UpgradeToWrite();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; primitives.size(); ++i)</div><div class="line">        &#123;</div><div class="line">            Reference&lt;Primitive&gt; &amp;prim = primitives[i];</div><div class="line">            &lt;Refine primitive prim <span class="keyword">if</span> it’s not intersectable <span class="number">207</span>&gt;</div><div class="line">        &#125;</div><div class="line">     allCanIntersect = <span class="literal">true</span>;</div><div class="line">     lock.DowngradeToRead();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>细化后要求所有的图元都可求交。若多于一个图元被返回，则创建一个新的GridAccel，用来存放被返回的多个图元。这样做的原因是为了简化图元细化，因为这样不会增加体元中图元的个数。如果该图元和多个体元重叠，由于它们都有指向同一个图元的引用，所以只需直接更新图元引用，而不需要循环遍历体元。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;Refine primitive prim <span class="keyword">if</span> it’s not intersectable&gt; ≡ <span class="number">206</span></div><div class="line">    <span class="keyword">if</span> (!prim-&gt;CanIntersect())</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; p;</div><div class="line">        prim-&gt;FullyRefine(p);</div><div class="line">        <span class="keyword">if</span> (p.size() == <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            primitives[i] = p[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            primitives[i] = <span class="keyword">new</span> GridAccel(p, <span class="literal">false</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>一旦确定体元中所有的图元都是可求交的，循环遍历图元求交点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;Loop over primitives in voxel and find intersections&gt; ≡ <span class="number">206</span></div><div class="line">    <span class="keyword">bool</span> hitSomething = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; primitives.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        Reference&lt;Primitive&gt; &amp;prim = primitives[i];</div><div class="line">        <span class="keyword">if</span> (prim-&gt;Intersect(ray, isect))</div><div class="line">        &#123;</div><div class="line">            hitSomething = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hitSomething;</div></pre></td></tr></table></figure></p>
<p>做完当前体元中的图元求交测试后，就要沿着光线路径下一个体元。网格必须确定下一步是在x方向，y方向，还是z方向。为此，NextCrossingT给出了每个方向上光线的下一个交叉点的参数距离，只需选择最小值所在的轴。如果下一步走出了网格，或者所选择的NextCrossingT的值被已找到的交点距离t还要远，遍历结束。否则，就要进入下一个选定的体元，并为选定方向上的NextCrossingT加上DeltaT，这样将来的遍历会知道在这个方向上还要走多远。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;Advance to next voxel&gt; ≡ <span class="number">205</span></div><div class="line">    &lt;Find stepAxis <span class="keyword">for</span> stepping to next voxel <span class="number">208</span>&gt;</div><div class="line">    <span class="keyword">if</span> (ray.maxt &lt; NextCrossingT[stepAxis])</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    Pos[stepAxis] += Step[stepAxis];</div><div class="line">    <span class="keyword">if</span> (Pos[stepAxis] == Out[stepAxis])</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    NextCrossingT[stepAxis] += DeltaT[stepAxis];</div></pre></td></tr></table></figure></p>
<p>选定下一步的方向需要求三个值的最小值。减少分支语句（条件）可以优化计算。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Find stepAxis <span class="keyword">for</span> stepping to next voxel&gt; ≡ <span class="number">207</span></div><div class="line">    <span class="keyword">int</span> bits = ((NextCrossingT[<span class="number">0</span>] &lt; NextCrossingT[<span class="number">1</span>]) &lt;&lt; <span class="number">2</span>) +</div><div class="line">               ((NextCrossingT[<span class="number">0</span>] &lt; NextCrossingT[<span class="number">2</span>]) &lt;&lt; <span class="number">1</span>) +</div><div class="line">               ((NextCrossingT[<span class="number">1</span>] &lt; NextCrossingT[<span class="number">2</span>]));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cmpToAxis[<span class="number">8</span>] = &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">int</span> stepAxis = cmpToAxis[bits];</div></pre></td></tr></table></figure></p>
<p>网格加速结构还提供了一个特殊的GridAccel::IntersectP()函数，用来检查沿阴影光线上的求交检查，只需要知道是否有交点，而不需要知道交点的细节。它跟GridAccel::Intersect()几乎相同，只不过它要调用Primitive::IntersectP()而不是Primitive::Intersect()，而且只有发现交点存在就立即返回。不再赘述。</p>
<h2 id="4-4-BVH加速结构-P237"><a href="#4-4-BVH加速结构-P237" class="headerlink" title="4.4 BVH加速结构 P237"></a>4.4 BVH加速结构 P237</h2><p>BVH通过将图元细分为层次不交集完成加速。BVH本质上是二叉树，图元被存放于二叉树的叶节点。BVH的实现详见accelerators/bvh.h和accelerators/bvh.cpp，构造函数种设置了一个字符串来确定树的构造算法，默认表面启发式（Surface Area Heuristic）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;BVHAccel Method Definitions&gt; ≡</div><div class="line">    BVHAccel::BVHAccel(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; &amp;p,</div><div class="line">                       <span class="keyword">uint32_t</span> mp, <span class="keyword">const</span> <span class="built_in">string</span> &amp;sm)</div><div class="line">    &#123;</div><div class="line">        maxPrimsInNode = min(<span class="number">255u</span>, mp);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; p.size(); ++i)</div><div class="line">        &#123;</div><div class="line">            p[i]-&gt;FullyRefine(primitives);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sm == <span class="string">"sah"</span>)</div><div class="line">        &#123;</div><div class="line">            splitMethod = SPLIT_SAH;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sm == <span class="string">"middle"</span>)</div><div class="line">        &#123;</div><div class="line">            splitMethod = SPLIT_MIDDLE;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sm == <span class="string">"equal"</span>)</div><div class="line">        &#123;</div><div class="line">            splitMethod = SPLIT_EQUAL_COUNTS;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            Warning(<span class="string">"BVH split method \"%s\" unknown. Using \"sah\"."</span>, sm.c_str());</div><div class="line">            splitMethod = SPLIT_SAH;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (primitives.size() == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            nodes = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        &lt;Build BVH from primitives <span class="number">210</span>&gt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;BVHAccel Private Data&gt; ≡</div><div class="line">    <span class="keyword">uint32_t</span> maxPrimsInNode;</div><div class="line">    <span class="keyword">enum</span> SplitMethod &#123; SPLIT_MIDDLE, SPLIT_EQUAL_COUNTS, SPLIT_SAH &#125;;</div><div class="line">    SplitMethod splitMethod;</div><div class="line">    <span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; primitives;</div></pre></td></tr></table></figure></p>
<h3 id="4-4-1-BVH构造"><a href="#4-4-1-BVH构造" class="headerlink" title="4.4.1 BVH构造"></a>4.4.1 BVH构造</h3><p>三个阶段。其一，计算每个图元的边界信息存于数组；其二，通过将图元递归的分裂到子集种完成树的构建；其三，整理树的结构使其紧凑。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Build BVH from primitives&gt; ≡ <span class="number">209</span></div><div class="line">    &lt;Initialize buildData <span class="built_in">array</span> <span class="keyword">for</span> primitives <span class="number">210</span>&gt;</div><div class="line">    &lt;Recursively build BVH tree <span class="keyword">for</span> primitives <span class="number">211</span>&gt;</div><div class="line">    &lt;Compute representation of depth-first traversal of BVH tree <span class="number">223</span>&gt;</div></pre></td></tr></table></figure></p>
<p>BVH种的每个图元被置入BVHPrimitiveInfo结构中，在树的建立过程中buildData会递归存储并分割图元。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;Initialize buildData <span class="built_in">array</span> <span class="keyword">for</span> primitives&gt; ≡ <span class="number">210</span></div><div class="line">    <span class="built_in">vector</span>&lt;BVHPrimitiveInfo&gt; buildData;</div><div class="line">    buildData.reserve(primitives.size());</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; primitives.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        BBox bbox = primitives[i]-&gt;WorldBound();</div><div class="line">        buildData.push_back(BVHPrimitiveInfo(i, bbox));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&lt;BVHAccel Local Declarations&gt; ≡</div><div class="line">    <span class="keyword">struct</span> BVHPrimitiveInfo</div><div class="line">    &#123;</div><div class="line">        BVHPrimitiveInfo(<span class="keyword">int</span> pn, <span class="keyword">const</span> BBox &amp;b)</div><div class="line">            : primitiveNumber(pn), bounds(b)</div><div class="line">        &#123;</div><div class="line">            centroid = <span class="number">.5</span>f * b.pMin + <span class="number">.5</span>f * b.pMax;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> primitiveNumber;</div><div class="line">        Point centroid;</div><div class="line">        BBox bounds;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>开始，recursiveBuild()函数将所有图元存入树种并返回根指针，使用MemoryArena为结点按个分配内存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;Recursively build BVH tree <span class="keyword">for</span> primitives&gt; ≡ <span class="number">210</span></div><div class="line">    MemoryArena buildArena;</div><div class="line">    <span class="keyword">uint32_t</span> totalNodes = <span class="number">0</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; orderedPrims;</div><div class="line">    orderedPrims.reserve(primitives.size());</div><div class="line">    BVHBuildNode *root = recursiveBuild(buildArena, buildData, <span class="number">0</span>,</div><div class="line">                                        primitives.size(), &amp;totalNodes,</div><div class="line">                                        orderedPrims);</div><div class="line">    primitives.swap(orderedPrims);</div></pre></td></tr></table></figure></p>
<p>每个BVHBuildNode代表BVH中一个结点。除了包围盒和子结点，还需要分裂所沿坐标轴以及其图元在图元数组中偏移位置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;BVHAccel Local Declarations&gt; +≡</div><div class="line">    <span class="keyword">struct</span> BVHBuildNode</div><div class="line">    &#123;</div><div class="line">        &lt;BVHBuildNode Public Methods <span class="number">212</span>&gt;</div><div class="line">        BBox bounds;</div><div class="line">        BVHBuildNode *children[<span class="number">2</span>];</div><div class="line">        <span class="keyword">uint32_t</span> splitAxis, firstPrimOffset, nPrimitives;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>构造函数只是置空子结点指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;BVHBuildNode Public Methods&gt; ≡ <span class="number">211</span></div><div class="line">    BVHBuildNode()</div><div class="line">    &#123;</div><div class="line">        children[<span class="number">0</span>] = children[<span class="number">1</span>] = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitLeaf</span><span class="params">(<span class="keyword">uint32_t</span> first, <span class="keyword">uint32_t</span> n, <span class="keyword">const</span> BBox &amp;b)</span></span></div><div class="line">    &#123;</div><div class="line">        firstPrimOffset = first;</div><div class="line">        nPrimitives = n;</div><div class="line">        bounds = b;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>函数InitInterior()需要在两个子节点都确定时被调用。此时父节点的包围盒可更新。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;BVHBuildNode Public Methods&gt; +≡ <span class="number">211</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitInterior</span><span class="params">(<span class="keyword">uint32_t</span> axis, BVHBuildNode *c0, BVHBuildNode *c1)</span></span></div><div class="line">    &#123;</div><div class="line">        children[<span class="number">0</span>] = c0;</div><div class="line">        children[<span class="number">1</span>] = c1;</div><div class="line">        bounds = Union(c0-&gt;bounds, c1-&gt;bounds);</div><div class="line">        splitAxis = axis;</div><div class="line">        nPrimitives = <span class="number">0</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>函数recursiveBuild()的范围从buildData[start]到buildData[end-1]，将区间递归划分到子集合中。成员totalNodes追踪了被创建的节点总数，orderedPrims数组储存了图元的引用，最后它将替代orderedPrims。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;BVHAccel Method Definitions&gt; +≡</div><div class="line">    BVHBuildNode *BVHAccel::recursiveBuild(MemoryArena &amp;buildArena,</div><div class="line">        <span class="built_in">vector</span>&lt;BVHPrimitiveInfo&gt; &amp;buildData, <span class="keyword">uint32_t</span> start,</div><div class="line">        <span class="keyword">uint32_t</span> end, <span class="keyword">uint32_t</span> *totalNodes,</div><div class="line">        <span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; &amp;orderedPrims)</div><div class="line">    &#123;</div><div class="line">        (*totalNodes)++;</div><div class="line">        BVHBuildNode *node = buildArena.Alloc&lt;BVHBuildNode&gt;();</div><div class="line">        BBox bbox;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = start; i &lt; end; ++i)</div><div class="line">        &#123;</div><div class="line">            bbox = Union(bbox, buildData[i].bounds);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">uint32_t</span> nPrimitives = end - start;</div><div class="line">        <span class="keyword">if</span> (nPrimitives == <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            &lt;Create leaf BVHBuildNode <span class="number">213</span>&gt;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            &lt;Compute bound of primitive centroids, choose split dimension dim <span class="number">214</span>&gt;                &lt;Partition primitives into two sets and build children <span class="number">215</span>&gt;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在叶结点，和叶重叠的图元被置入orderedPrims数组并初始化叶节点对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Create leaf BVHBuildNode&gt; ≡ <span class="number">213</span>, <span class="number">215</span>, <span class="number">221</span></div><div class="line">    <span class="keyword">uint32_t</span> firstPrimOffset = orderedPrims.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = start; i &lt; end; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">uint32_t</span> primNum = buildData[i].primitiveNumber;</div><div class="line">        orderedPrims.push_back(primitives[primNum]);</div><div class="line">    &#125;</div><div class="line">    node-&gt;InitLeaf(firstPrimOffset, nPrimitives, bbox);</div></pre></td></tr></table></figure></p>
<p>对于内部节点，首先选择图元分区的坐标轴，选择标准是看哪个轴拥有最大的包围盒图心范围，并且要求图元之间没有太多的重叠。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Compute bound of primitive centroids, choose split dimension dim&gt; ≡ <span class="number">213</span></div><div class="line">    BBox centroidBounds;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = start; i &lt; end; ++i)</div><div class="line">    &#123;</div><div class="line">        centroidBounds = Union(centroidBounds, buildData[i].centroid);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> dim = centroidBounds.MaximumExtent();</div></pre></td></tr></table></figure></p>
<p>如果所有的图心点在相同位置，也就是图心边界范围是0，递归停止创建叶结点；否则继续划分，递归。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;Partition primitives into two sets and build children&gt; ≡ <span class="number">213</span></div><div class="line">    <span class="keyword">uint32_t</span> mid = (start + end) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (centroidBounds.pMax[dim] == centroidBounds.pMin[dim])</div><div class="line">    &#123;</div><div class="line">        &lt;Create leaf BVHBuildNode <span class="number">213</span>&gt;</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">    &#125;</div><div class="line">    &lt;Partition primitives based on splitMethod&gt;</div><div class="line">    node-&gt;InitInterior(dim, recursiveBuild(buildArena, buildData, start, mid,</div><div class="line">                       totalNodes, orderedPrims),</div><div class="line">    recursiveBuild(buildArena, buildData, mid, end, totalNodes, orderedPrims));</div></pre></td></tr></table></figure></p>
<p>图元的划分使用BVHAccel::splitMethod决定划分方式。最简单的是SPLIT_MIDDLE，计算图心区间范围的中点然后二分。借助std::partition轻易完成。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;Partition primitives through node’s midpoint&gt; ≡</div><div class="line">    <span class="keyword">float</span> pmid = <span class="number">.5</span>f * (centroidBounds.pMin[dim] + centroidBounds.pMax[dim]);</div><div class="line">    BVHPrimitiveInfo *midPtr = <span class="built_in">std</span>::partition(&amp;buildData[start],</div><div class="line">                                              &amp;buildData[end<span class="number">-1</span>]+<span class="number">1</span>,</div><div class="line">                                              CompareToMid(dim, pmid));</div><div class="line">    mid = midPtr - &amp;buildData[<span class="number">0</span>];</div><div class="line"></div><div class="line">&lt;BVHAccel Local Declarations&gt; +≡</div><div class="line">    <span class="keyword">struct</span> CompareToMid</div><div class="line">    &#123;</div><div class="line">        CompareToMid(<span class="keyword">int</span> d, <span class="keyword">float</span> m)</div><div class="line">        &#123;</div><div class="line">            dim = d;</div><div class="line">            mid = m;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> dim;</div><div class="line">        <span class="keyword">float</span> mid;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> BVHPrimitiveInfo &amp;a)</span> <span class="keyword">const</span></span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> a.centroid[dim] &lt; mid;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>另一种直观的划分方式，SPLIT_EQUAL_COUNTS，它将图元划分成两个相等的子集。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;Partition primitives into equally-sized subsets&gt; ≡ <span class="number">219</span></div><div class="line">    mid = (start + end) / <span class="number">2</span>;</div><div class="line">    <span class="built_in">std</span>::nth_element(&amp;buildData[start], &amp;buildData[mid],</div><div class="line">                     &amp;buildData[end<span class="number">-1</span>]+<span class="number">1</span>, ComparePoints(dim));</div><div class="line"></div><div class="line">&lt;BVHAccel Local Declarations&gt; +≡</div><div class="line">    <span class="keyword">struct</span> ComparePoints</div><div class="line">    &#123;</div><div class="line">        ComparePoints(<span class="keyword">int</span> d)</div><div class="line">        &#123;</div><div class="line">            dim = d;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> dim;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> BVHPrimitiveInfo &amp;a,</span></span></div><div class="line">                        <span class="keyword">const</span> BVHPrimitiveInfo &amp;b) <span class="keyword">const</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> a.centroid[dim] &lt; b.centroid[dim];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<h3 id="4-4-2-表面积启发式，"><a href="#4-4-2-表面积启发式，" class="headerlink" title="4.4.2 表面积启发式，"></a>4.4.2 表面积启发式，</h3><p>SAH是最具普遍性的划分算法，尽管对于小数目的图元来说可能有些得不偿失。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;Partition primitives <span class="keyword">using</span> approximate SAH&gt; ≡</div><div class="line">    <span class="keyword">if</span> (nPrimitives &lt;= <span class="number">4</span>)</div><div class="line">    &#123;</div><div class="line">        &lt;Partition primitives into equally-sized subsets <span class="number">217</span>&gt;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        &lt;Allocate BucketInfo <span class="keyword">for</span> SAH partition buckets <span class="number">219</span>&gt;</div><div class="line">        &lt;Initialize BucketInfo <span class="keyword">for</span> SAH partition buckets <span class="number">220</span>&gt;</div><div class="line">        &lt;Compute costs <span class="keyword">for</span> splitting after each bucket <span class="number">221</span>&gt;</div><div class="line">        &lt;Find bucket to split at that minimizes SAH metric <span class="number">221</span>&gt;</div><div class="line">        &lt;Either create leaf or split primitives at selected SAH bucket <span class="number">221</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>SAH将图心区间沿轴划分为若干的等长区域（Bucket），然后只考虑区域边界的划分。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;Allocate BucketInfo <span class="keyword">for</span> SAH partition buckets&gt; ≡ <span class="number">219</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nBuckets = <span class="number">12</span>;</div><div class="line">    <span class="keyword">struct</span> BucketInfo</div><div class="line">    &#123;</div><div class="line">        BucketInfo()</div><div class="line">        &#123;</div><div class="line">            count = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    BBox bounds;</div><div class="line">    &#125;;</div><div class="line">    BucketInfo buckets[nBuckets];</div></pre></td></tr></table></figure></p>
<p>对于区间内的每个图元，使其图心投影至区域上，并更新区域的范围使其包括图元的范围。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;Initialize BucketInfo <span class="keyword">for</span> SAH partition buckets&gt; ≡ <span class="number">219</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = start; i &lt; end; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> b = nBuckets *</div><div class="line">                ((buildData[i].centroid[dim] - centroidBounds.pMin[dim]) /</div><div class="line">                (centroidBounds.pMax[dim] - centroidBounds.pMin[dim]));</div><div class="line">        <span class="keyword">if</span> (b == nBuckets)</div><div class="line">        &#123;</div><div class="line">            b = nBuckets<span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        buckets[b].count++;</div><div class="line">        buckets[b].bounds = Union(buckets[b].bounds, buildData[i].bounds);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对于每个区域，现在拥有了图元的计数和各自的包围盒。现在需要用SAH估算在每个区域处划分的成本，并将每个区域的成本储存与cost[i]中。注意，首尾两个区域不能够被划分。钦定定求交消耗1，遍历消耗1/8。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;Compute costs <span class="keyword">for</span> splitting after each bucket&gt; ≡ <span class="number">219</span></div><div class="line">    <span class="keyword">float</span> cost[nBuckets<span class="number">-1</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nBuckets<span class="number">-1</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        BBox b0, b1;</div><div class="line">        <span class="keyword">int</span> count0 = <span class="number">0</span>, count1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</div><div class="line">        &#123;</div><div class="line">            b0 = Union(b0, buckets[j].bounds);</div><div class="line">            count0 += buckets[j].count;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nBuckets; ++j)</div><div class="line">        &#123;</div><div class="line">            b1 = Union(b1, buckets[j].bounds);</div><div class="line">            count1 += buckets[j].count;</div><div class="line">        &#125;</div><div class="line">        cost[i] = <span class="number">.125</span>f + (count0*b0.SurfaceArea() + </div><div class="line">                           count1*b1.SurfaceArea()) /bbox.SurfaceArea();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>然后从cost数组中找到最小值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;Find bucket to split at that minimizes SAH metric&gt; ≡ <span class="number">219</span></div><div class="line">    <span class="keyword">float</span> minCost = cost[<span class="number">0</span>];</div><div class="line">    <span class="keyword">uint32_t</span> minCostSplit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nBuckets<span class="number">-1</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (cost[i] &lt; minCost)</div><div class="line">        &#123;</div><div class="line">            minCost = cost[i];</div><div class="line">            minCostSplit = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果划分区域的成本小于建立一个图元结点或超过了一个结点允许的最大图元数，std::partition()会将buildData数组中的结点重排序。因为之前的求交消耗是钦定的1，所以创建叶结点的消耗等于图元数量即nPrimitives。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;Either create leaf or split primitives at selected SAH bucket&gt; ≡ <span class="number">219</span></div><div class="line">    <span class="keyword">if</span> (nPrimitives &gt; maxPrimsInNode || minCost &lt; nPrimitives)</div><div class="line">    &#123;</div><div class="line">        BVHPrimitiveInfo *pmid = <span class="built_in">std</span>::partition(&amp;buildData[start],</div><div class="line">                                                &amp;buildData[end<span class="number">-1</span>]+<span class="number">1</span>,</div><div class="line">                    CompareToBucket(minCostSplit, nBuckets, dim, centroidBounds));</div><div class="line">        mid = pmid - &amp;buildData[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        &lt;Create leaf BVHBuildNode <span class="number">213</span>&gt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;BVHAccel Local Declarations&gt; +≡</div><div class="line">    <span class="keyword">struct</span> CompareToBucket</div><div class="line">    &#123;</div><div class="line">        CompareToBucket(<span class="keyword">int</span> split, <span class="keyword">int</span> num, <span class="keyword">int</span> d, <span class="keyword">const</span> BBox &amp;b)</div><div class="line">            : centroidBounds(b)</div><div class="line">        &#123;</div><div class="line">            splitBucket = split; nBuckets = num; dim = d;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> BVHPrimitiveInfo &amp;p)</span> <span class="keyword">const</span></span>;</div><div class="line">        <span class="keyword">int</span> splitBucket, nBuckets, dim;</div><div class="line">        <span class="keyword">const</span> BBox &amp;centroidBounds;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>图元的划分包括了验算它映射到哪个区域并且将这个区域按照边界划分（口胡的）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;BVHAccel Local Declarations&gt; +≡</div><div class="line">    <span class="keyword">bool</span> CompareToBucket::<span class="keyword">operator</span>()(<span class="keyword">const</span> BVHPrimitiveInfo &amp;p) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> b = nBuckets * ((p.centroid[dim] - centroidBounds.pMin[dim]) /</div><div class="line">                           (centroidBounds.pMax[dim] - centroidBounds.pMin[dim]));</div><div class="line">        <span class="keyword">if</span> (b == nBuckets)</div><div class="line">        &#123;</div><div class="line">            b = nBuckets<span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> b &lt;= splitBucket;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-4-3-BVH的压缩"><a href="#4-4-3-BVH的压缩" class="headerlink" title="4.4.3 BVH的压缩"></a>4.4.3 BVH的压缩</h3><p>BVH建立后，要将它转换为紧凑表示以提高系统性能。最后得到的BVH应该以深度优先的方式存放在线性数组LinearBVHNode中。pad[2]作为填充保证32字节的大小。这么做的目的是使缓存对齐，保证后面的结点不从高速缓存线上岔开（现代CPU架构要求缓存线上至少32个字节）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;BVHAccel Local Declarations&gt; +≡</div><div class="line">    <span class="keyword">struct</span> LinearBVHNode</div><div class="line">    &#123;</div><div class="line">        BBox bounds;</div><div class="line">        <span class="keyword">union</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">uint32_t</span> primitivesOffset; <span class="comment">// leaf</span></div><div class="line">            <span class="keyword">uint32_t</span> secondChildOffset; <span class="comment">// interior</span></div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">uint8_t</span> nPrimitives; <span class="comment">// 0 -&gt; interior node</span></div><div class="line">        <span class="keyword">uint8_t</span> axis; <span class="comment">// interior node: xyz</span></div><div class="line">        <span class="keyword">uint8_t</span> pad[<span class="number">2</span>]; <span class="comment">// ensure 32 byte total size</span></div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>函数flattenBVHTree()完成转换操作。DFS进线性内存中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;BVHAccel Private Data&gt; +≡</div><div class="line">    LinearBVHNode *nodes;</div><div class="line"></div><div class="line">&lt;Compute representation of depth-first traversal of BVH tree&gt; ≡ <span class="number">210</span></div><div class="line">    nodes = AllocAligned&lt;LinearBVHNode&gt;(totalNodes);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; totalNodes; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">new</span> (&amp;nodes[i]) LinearBVHNode;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">uint32_t</span> offset = <span class="number">0</span>;</div><div class="line">    flattenBVHTree(root, &amp;offset);</div></pre></td></tr></table></figure></p>
<p>参数offset追踪了当前的偏移量。注意先将当前结点塞进数组，再递归调用它的子结点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;BVHAccel Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">uint32_t</span> BVHAccel::flattenBVHTree(BVHBuildNode *node, <span class="keyword">uint32_t</span> *offset)</div><div class="line">    &#123;</div><div class="line">        LinearBVHNode *linearNode = &amp;nodes[*offset];</div><div class="line">        linearNode-&gt;bounds = node-&gt;bounds;</div><div class="line">        <span class="keyword">uint32_t</span> myOffset = (*offset)++;</div><div class="line">        <span class="keyword">if</span> (node-&gt;nPrimitives &gt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            linearNode-&gt;primitivesOffset = node-&gt;firstPrimOffset;</div><div class="line">            linearNode-&gt;nPrimitives = node-&gt;nPrimitives;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            linearNode-&gt;axis = node-&gt;splitAxis;</div><div class="line">            linearNode-&gt;nPrimitives = <span class="number">0</span>;</div><div class="line">            flattenBVHTree(node-&gt;children[<span class="number">0</span>], offset);</div><div class="line">            linearNode-&gt;secondChildOffset = </div><div class="line">                    flattenBVHTree(node-&gt;children[<span class="number">1</span>], offset);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> myOffset;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-4-4-遍历"><a href="#4-4-4-遍历" class="headerlink" title="4.4.4 遍历"></a>4.4.4 遍历</h3><p>Intersect()函数预计算一些和光照有关的会被反复用到的数据。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;BVHAccel Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">bool</span> BVHAccel::Intersect(<span class="keyword">const</span> Ray &amp;ray, Intersection *isect) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (!nodes) </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">bool</span> hit = <span class="literal">false</span>;</div><div class="line">        Point origin = ray(ray.mint);</div><div class="line">        <span class="function">Vector <span class="title">invDir</span><span class="params">(<span class="number">1.f</span> / ray.d.x, <span class="number">1.f</span> / ray.d.y, <span class="number">1.f</span> / ray.d.z)</span></span>;</div><div class="line">        <span class="keyword">uint32_t</span> dirIsNeg[<span class="number">3</span>] = &#123; invDir.x &lt; <span class="number">0</span>, invDir.y &lt; <span class="number">0</span>, invDir.z &lt; <span class="number">0</span> &#125;;</div><div class="line">        &lt;Follow ray through BVH nodes to find primitive intersections <span class="number">225</span>&gt;</div><div class="line">        <span class="keyword">return</span> hit;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数中每次迭代，nodeNum记录了当前被访问结点的偏移量，它始于0，代表树的根。todo[]作为栈存储了还需要被访问的结点，todoOffset自然表示栈中偏移量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Follow ray through BVH nodes to find primitive intersections&gt; ≡ <span class="number">224</span></div><div class="line">    <span class="keyword">uint32_t</span> todoOffset = <span class="number">0</span>, nodeNum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">uint32_t</span> todo[<span class="number">64</span>];</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">const</span> LinearBVHNode *node = &amp;nodes[nodeNum];</div><div class="line">        &lt;Check ray against BVH node <span class="number">225</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对于每个结点，检查光线是否与包围盒相交（或是否始于包围盒内部）。若相交，那么求图元交点（叶）或进一步检查其子结点（内）；若不相交，从todo[]中找到下一个结点的偏移量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;Check ray against BVH node&gt; ≡ <span class="number">225</span></div><div class="line">    <span class="keyword">if</span> (::IntersectP(node-&gt;bounds, ray, invDir, dirIsNeg))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (node-&gt;nPrimitives &gt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            &lt;Intersect ray with primitives in leaf BVH node <span class="number">226</span>&gt;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            &lt;Put far BVH node on todo <span class="built_in">stack</span>, advance to near node <span class="number">227</span>&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (todoOffset == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        nodeNum = todo[--todoOffset];</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>BVHAccel中使用函数IntersectP()检查光线和包围盒的交点。它用一个方向向量表示实际方向的倒数，在BBox::IntersectP()基础上做了三点微小的优化：</p>
<ul>
<li>展开了for循环</li>
<li>倒数是预计算并传入的，使得光线和包围盒求交测试的结果重复使用变为可能</li>
<li>光线的方向符号是预计算的，使得直接计算各自的远近值而不需要与tNear和tFar相比较</li>
</ul>
<p>此外，当光线的片段完全在包围盒中会返回true即便交点不在光的[mint, maxt]范围之内，这一特性是为BVH遍历服务的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;BVHAccel Local Declarations&gt; +≡</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IntersectP</span><span class="params">(<span class="keyword">const</span> BBox &amp;bounds, <span class="keyword">const</span> Ray &amp;ray,</span></span></div><div class="line">        <span class="keyword">const</span> Vector &amp;invDir, <span class="keyword">const</span> <span class="keyword">uint32_t</span> dirIsNeg[<span class="number">3</span>])</div><div class="line">    &#123;</div><div class="line">        &lt;Check <span class="keyword">for</span> ray intersection against x and y slabs <span class="number">226</span>&gt;</div><div class="line">        &lt;Check <span class="keyword">for</span> ray intersection against z slab&gt;</div><div class="line">        <span class="keyword">return</span> (tmin &lt; ray.maxt) &amp;&amp; (tmax &gt; ray.mint);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果光的方向是负，近的参数交点会是平板与包围盒交点的较大值，远的交点是较小值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;Check <span class="keyword">for</span> ray intersection against x and y slabs&gt; ≡ <span class="number">226</span></div><div class="line">    <span class="keyword">float</span> tmin = (bounds[ dirIsNeg[<span class="number">0</span>]].x - ray.o.x) * invDir.x;</div><div class="line">    <span class="keyword">float</span> tmax = (bounds[<span class="number">1</span>-dirIsNeg[<span class="number">0</span>]].x - ray.o.x) * invDir.x;</div><div class="line">    <span class="keyword">float</span> tymin = (bounds[ dirIsNeg[<span class="number">1</span>]].y - ray.o.y) * invDir.y;</div><div class="line">    <span class="keyword">float</span> tymax = (bounds[<span class="number">1</span>-dirIsNeg[<span class="number">1</span>]].y - ray.o.y) * invDir.y;</div><div class="line">    <span class="keyword">if</span> ((tmin &gt; tymax) || (tymin &gt; tmax))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (tymin &gt; tmin)</div><div class="line">    &#123;</div><div class="line">        tmin = tymin;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (tymax &lt; tmax)</div><div class="line">    &#123;</div><div class="line">        tmax = tymax;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果当前结点是叶，下一步测试光线和叶内图元的交点。遍历todo栈中所有的结点，并且及时更新maxt值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;Intersect ray with primitives in leaf BVH node&gt; ≡ <span class="number">225</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; node-&gt;nPrimitives; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (primitives[node-&gt;primitivesOffset+i]-&gt;Intersect(ray, isect))</div><div class="line">        &#123;</div><div class="line">            hit = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (todoOffset == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    nodeNum = todo[--todoOffset];</div></pre></td></tr></table></figure></p>
<p>对于光线击中的所有内部结点，访问其所有的子结点。通过光线的方向符号对子结点的访问顺序进行分割：如果符号为负，先访问第二个结点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;Put far BVH node on todo <span class="built_in">stack</span>, advance to near node&gt; ≡ <span class="number">225</span></div><div class="line">    <span class="keyword">if</span> (dirIsNeg[node-&gt;axis])</div><div class="line">    &#123;</div><div class="line">        todo[todoOffset++] = nodeNum + <span class="number">1</span>;</div><div class="line">        nodeNum = node-&gt;secondChildOffset;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        todo[todoOffset++] = node-&gt;secondChildOffset;</div><div class="line">        nodeNum = nodeNum + <span class="number">1</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-5-KD树加速结构-P256"><a href="#4-5-KD树加速结构-P256" class="headerlink" title="4.5 KD树加速结构 P256"></a>4.5 KD树加速结构 P256</h2><p>二元空间分割树（Binary Space Partitioning，BSP）自适应地把空间分割成大小不一的区域。BSP面对几何体分布不均的场景是更高效的数据结构。BSP始于一个包含整个场景的包围盒。若盒中图元数目超过某阈值，就用一个平面将包围盒一分为二。图元与它所重叠的那半空间联系在一起，如果图元和两个空间都重叠，则和两个空间都要联系起来。这个分割过程要递归地进行下去，直到每个叶空间内的图元树足够少，或者递归的深度已经达到阈值。因为分割平面可以在空间内任意位置并且可以对三维空间的不同部分做不同程度的分割，因此BSP可以处理不均匀的几何体。<br>BSP的两个变式：KD树和八叉树（Octrees）。KD树要求分割平面必须垂直于某个坐标轴，这使得树便于创建和遍历，但自然牺牲了某些关于分割的灵活性。而八叉树用三个和轴垂直的平面把空间分割成八个区域。详见accelerators/kdtreeaccel.h和accelerators/kdtreeaccel.cpp。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;KdTreeAccel Declarations&gt; ≡</div><div class="line">    <span class="keyword">class</span> KdTreeAccel : <span class="keyword">public</span> Aggregate</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        &lt;KdTreeAccel Public Methods <span class="number">245</span>&gt;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        &lt;KdTreeAccel Private Methods&gt;</div><div class="line">        &lt;KdTreeAccel Private Data <span class="number">229</span>&gt;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>KdTreeAccel构造函数包括图元的引用，还有和创建树相关的参数。这些参数被存放在成员变量中备用（isectCost，traversalCost，maxPrims，maxDepth，emptyBonus）。此外，KdTreeAccel要求所有图元可求交。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;KdTreeAccel Method Definitions&gt; ≡</div><div class="line">    KdTreeAccel::KdTreeAccel(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; &amp;p,</div><div class="line">                             <span class="keyword">int</span> icost, <span class="keyword">int</span> tcost, <span class="keyword">float</span> ebonus, <span class="keyword">int</span> maxp,</div><div class="line">                             <span class="keyword">int</span> md)</div><div class="line">        : isectCost(icost), traversalCost(tcost), maxPrims(maxp),</div><div class="line">          maxDepth(md), emptyBonus(ebonus)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; p.size(); ++i)</div><div class="line">        &#123;</div><div class="line">            p[i]-&gt;FullyRefine(primitives);</div><div class="line">        &#125;</div><div class="line">        &lt;Build kd-tree <span class="keyword">for</span> accelerator <span class="number">232</span>&gt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;KdTreeAccel Private Data&gt; ≡ <span class="number">228</span></div><div class="line">    <span class="keyword">int</span> isectCost, traversalCost, maxPrims, maxDepth;</div><div class="line">    <span class="keyword">float</span> emptyBonus;</div><div class="line">    <span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; primitives;</div></pre></td></tr></table></figure></p>
<h3 id="4-5-1-树的表示"><a href="#4-5-1-树的表示" class="headerlink" title="4.5.1 树的表示"></a>4.5.1 树的表示</h3><p>KD树，二叉树。每个内部结点必须存放以下数据。</p>
<ul>
<li>分割轴：该节点采用哪一轴（x，y，z）进行分割</li>
<li>分割位置：分割平面在坐标轴上的位置</li>
<li>子结点：存储到达子结点的方式</li>
</ul>
<p>每个叶子结点只存放和该区域重叠的图元。此外，一个额外的工作是使所有的内部结点和大部分的叶结点都占中8个字节（假定浮点数和指针都占用4字节）以保证4个结点刚好占满32字节的缓存线。由于树上有大量的结点且每条光线要用到大量的结点，因此减少结点的内存使用可以极大地提高缓存效率（16个字节存放结点改为8个字节后大概提速20%）。叶结点和内部结点都使用KdAccelNode。union说明了这个成员是用在内部结点，还是叶结点，还是两者都用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;KdTreeAccel Local Declarations&gt; ≡</div><div class="line">    <span class="keyword">struct</span> KdAccelNode</div><div class="line">    &#123;</div><div class="line">        &lt;KdAccelNode Methods <span class="number">231</span>&gt;</div><div class="line">        <span class="keyword">union</span> </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">float</span> split; <span class="comment">// Interior</span></div><div class="line">            <span class="keyword">uint32_t</span> onePrimitive; <span class="comment">// Leaf</span></div><div class="line">            <span class="keyword">uint32_t</span> *primitives; <span class="comment">// Leaf</span></div><div class="line">        &#125;;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">union</span> </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">uint32_t</span> flags; <span class="comment">// Both</span></div><div class="line">            <span class="keyword">uint32_t</span> nPrims; <span class="comment">// Leaf</span></div><div class="line">            <span class="keyword">uint32_t</span> aboveChild; <span class="comment">// Interior</span></div><div class="line">        &#125;;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>KdAccelNode::flags的最低两位用来区别被x、y或z轴分割的内部结点（0，1，2）和叶结点(3)。为把叶结点放入8字节的内存：flags的低两位用于表示它是叶，nPrims的高30位用来表示有多少体素跟它重叠。同GridAccel，如果只有一个图元和叶重叠，那么primitives中一个uint索引表示这个图元；如果多个图元，表示图元索引的动态数组指向primitives。<br>叶的初始化。因为flags和nPrims共享数据，小心对nPrims初始化时不要影响到flags而把它的值变为乱码，所以在把图元个数存放到结点之前把它左移两位并把KdAccelNode:flags的低两位设置为3。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;KdTreeAccel Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">void</span> KdAccelNode::initLeaf(<span class="keyword">uint32_t</span> *primNums, <span class="keyword">int</span> np,</div><div class="line">                               MemoryArena &amp;arena)</div><div class="line">    &#123;</div><div class="line">        flags = <span class="number">3</span>;</div><div class="line">        nPrims |= (np &lt;&lt; <span class="number">2</span>);</div><div class="line">        &lt;Store primitive ids <span class="keyword">for</span> leaf node <span class="number">230</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>因为onePrimitived的存在使那些有0个或1个图元的叶结点没有必要申请内存。如果有多个图元，MemoryArena。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;Store primitive ids <span class="keyword">for</span> leaf node&gt; ≡ <span class="number">230</span></div><div class="line">    <span class="keyword">if</span> (np == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        onePrimitive = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (np == <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        onePrimitive = primNums[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        primitives = arena.Alloc&lt;<span class="keyword">uint32_t</span>&gt;(np);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; np; ++i)</div><div class="line">        &#123;</div><div class="line">            primitives[i] = primNums[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>下一步将内部结点8字节化。上已述flags的最低2位记录了分割轴，剩下的工作便是存储子结点的联系方式。这里，只存储一个子结点的指针，而不是选择存储两个指针或偏移量。原因在于所有的结点占用一块连续的内存，代表分割面下部区域的那个子结点被放置在紧靠其父结点的位置（这也能提高缓存效率），而另一个代表分割面上部区域的那个子结点将被放在数组的另一个位置，aboveChild存储了这个偏移量。同initLeaf()，要把flags赋值在aboveChild之前。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;KdAccelNode Methods&gt; ≡ <span class="number">229</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initInterior</span><span class="params">(<span class="keyword">uint32_t</span> axis, <span class="keyword">uint32_t</span> ac, <span class="keyword">float</span> s)</span></span></div><div class="line">    &#123;</div><div class="line">        split = s;</div><div class="line">        flags = axis;</div><div class="line">        aboveChild |= (ac &lt;&lt; <span class="number">2</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>最后，提供辅助函数从结点中提取关键参数。具体实现不再赘述。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;KdAccelNode Methods&gt; +≡ <span class="number">229</span></div><div class="line">    <span class="function"><span class="keyword">float</span> <span class="title">SplitPos</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> split; &#125;</div><div class="line">    <span class="keyword">uint32_t</span> nPrimitives() <span class="keyword">const</span> &#123; <span class="keyword">return</span> nPrims &gt;&gt; <span class="number">2</span>; &#125;</div><div class="line">    <span class="keyword">uint32_t</span> SplitAxis() <span class="keyword">const</span> &#123; <span class="keyword">return</span> flags &amp; <span class="number">3</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsLeaf</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (flags &amp; <span class="number">3</span>) == <span class="number">3</span>; &#125;</div><div class="line">    <span class="keyword">uint32_t</span> AboveChild() <span class="keyword">const</span> &#123; <span class="keyword">return</span> aboveChild &gt;&gt; <span class="number">2</span>; &#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-5-2-树的创建"><a href="#4-5-2-树的创建" class="headerlink" title="4.5.2 树的创建"></a>4.5.2 树的创建</h3><p>KD树是自顶向下递归创建。每一次循环，有一个轴对齐的空间区域和一组跟它重叠的图元。这个区域要么被分割成两个子区域并变成一个内部结点，要么创建一个叶子结点，结束递归。在讨论KdAccelNode时，所有树结点都被存放在一个内存连续的数组中。KdTreeAccel::nextFreeNode记录数组中下一个可用的结点，KdTreeAccel::nAllocedNodes记录已经分配内存的结点个数。它们的初始化值为0，确保当初始化第一个树结点时可以立即分配内存。此外，即便递归可以做到自动停止，提供缺省的最大递归深度以应付一些丧病的场景是很有必要的。钦定值8+1.3log(N)是一个很合理的最大深度。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Build kd-tree <span class="keyword">for</span> accelerator&gt; ≡ <span class="number">229</span></div><div class="line">    nextFreeNode = nAllocedNodes = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (maxDepth &lt;= <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        maxDepth = Round2Int(<span class="number">8</span> + <span class="number">1.3f</span> * Log2Int(<span class="keyword">float</span>(primitives.size())));</div><div class="line">    &#125;</div><div class="line">    &lt;Compute bounds <span class="keyword">for</span> kd-tree construction <span class="number">232</span>&gt;</div><div class="line">    &lt;Allocate working memory <span class="keyword">for</span> kd-tree construction <span class="number">236</span>&gt;</div><div class="line">    &lt;Initialize primNums <span class="keyword">for</span> kd-tree construction <span class="number">232</span>&gt;</div><div class="line">    &lt;Start recursive construction of kd-tree <span class="number">233</span>&gt;</div><div class="line">    &lt;Free working memory <span class="keyword">for</span> kd-tree construction&gt;</div><div class="line"></div><div class="line">&lt;KdTreeAccel Private Data&gt; +≡ <span class="number">228</span></div><div class="line">    KdAccelNode *nodes;</div><div class="line">    <span class="keyword">int</span> nAllocedNodes, nextFreeNode;</div></pre></td></tr></table></figure></p>
<p>因为构造过程要重复使用图元的包围盒，所以在构造树之前，将包围盒集中在一个vector中，以防对Primitive::WorldBound()的重复调用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;Compute bounds <span class="keyword">for</span> kd-tree construction&gt; ≡ <span class="number">232</span></div><div class="line">    <span class="built_in">vector</span>&lt;BBox&gt; primBounds;</div><div class="line">    primBounds.reserve(primitives.size());</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; primitives.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        BBox b = primitives[i]-&gt;WorldBound();</div><div class="line">        bounds = Union(bounds, b);</div><div class="line">        primBounds.push_back(b);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;KdTreeAccel Private Data&gt; +≡ <span class="number">228</span></div><div class="line">    BBox bounds;</div></pre></td></tr></table></figure></p>
<p>构造函数的参数之一是一个图元索引值数组，用来指定那些和当前结点重叠的图元。因为所有图元都和根结点重叠，所以在递归过程开始之前，我们用0到prims.size()-1来初始化一个数组，并用此数组作为递归的开始。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Initialize primNums <span class="keyword">for</span> kd-tree construction&gt; ≡ <span class="number">232</span></div><div class="line">    <span class="keyword">uint32_t</span> *primNums = <span class="keyword">new</span> <span class="keyword">uint32_t</span>[primitives.size()];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; primitives.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        primNums[i] = i;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>每个结点都要调用KdTreeAccel::buildTree()函数，这个函数负责确定该结点是内部结点还是叶结点，并更新相关的数据结构。最后三个参数edges、prims0和prims1，是指向内存分配片段中数据的指针，而这个片段的介绍在下文中。buildTree()函数的主要参数是结点的数组偏置值nodeNum，结点覆盖区域的包围盒nodeBounds，和它重叠的图元的索引值数组primNums。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;Start recursive construction of kd-tree&gt; ≡ <span class="number">232</span></div><div class="line">    buildTree(<span class="number">0</span>, bounds, primBounds, primNums, primitives.size(),</div><div class="line">              maxDepth, edges, prims0, prims1);</div><div class="line"></div><div class="line">&lt;KdTreeAccel Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">void</span> KdTreeAccel::buildTree(<span class="keyword">int</span> nodeNum, <span class="keyword">const</span> BBox &amp;nodeBounds,</div><div class="line">            <span class="keyword">const</span> <span class="built_in">vector</span>&lt;BBox&gt; &amp;allPrimBounds, <span class="keyword">uint32_t</span> *primNums,</div><div class="line">            <span class="keyword">int</span> nPrimitives, <span class="keyword">int</span> depth, BoundEdge *edges[<span class="number">3</span>],</div><div class="line">            <span class="keyword">uint32_t</span> *prims0, <span class="keyword">uint32_t</span> *prims1, <span class="keyword">int</span> badRefines)</div><div class="line">    &#123;</div><div class="line">        &lt;Get next <span class="built_in">free</span> node fromnodes <span class="built_in">array</span> <span class="number">233</span>&gt;</div><div class="line">        &lt;Initialize leaf node <span class="keyword">if</span> termination criteria met <span class="number">233</span>&gt;</div><div class="line">        &lt;Initialize interior node and <span class="keyword">continue</span> recursion <span class="number">234</span>&gt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果分配的结点被用尽，则会再分配两倍的结点空间，并把旧值拷贝到新内存区域。当buildTree()被第一次调用，nAllocNodes是0，所以要申请第一块结点内存空间。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;Get next <span class="built_in">free</span> node fromnodes <span class="built_in">array</span>&gt; ≡ <span class="number">233</span></div><div class="line">    <span class="keyword">if</span> (nextFreeNode == nAllocedNodes)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> nAlloc = max(<span class="number">2</span> * nAllocedNodes, <span class="number">512</span>);</div><div class="line">        KdAccelNode *n = AllocAligned&lt;KdAccelNode&gt;(nAlloc);</div><div class="line">        <span class="keyword">if</span> (nAllocedNodes &gt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">memcpy</span>(n, nodes, nAllocedNodes * <span class="keyword">sizeof</span>(KdAccelNode));</div><div class="line">            FreeAligned(nodes);</div><div class="line">        &#125;</div><div class="line">        nodes = n;</div><div class="line">        nAllocedNodes = nAlloc;</div><div class="line">    &#125;</div><div class="line">    ++nextFreeNode;</div></pre></td></tr></table></figure></p>
<p>如果区域内图元个数少于阈值或者已达到最大真毒，则停止递归并创建一个叶结点。参数depth为深度值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Initialize leaf node <span class="keyword">if</span> termination criteria met&gt; ≡ <span class="number">233</span></div><div class="line">    <span class="keyword">if</span> (nPrimitives &lt;= maxPrims || depth == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        nodes[nodeNum].initLeaf(primNums, nPrimitives, arena);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如前所述，initLeaf借助MemoryArena为可变图元数组申请内存空间。因为arena是一个成员变量，当KdTreeAccel对象被撤销时，它所分配的空间将被完全释放。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;KdTreeAccel Private Data&gt; +=</div><div class="line">    MemoryArena arena;</div></pre></td></tr></table></figure></p>
<p>如果这是一个内部结点，就必须选择一个分割平面，并将图元按照这个平面分类，再进行下一步的递归。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Initialize interior node and <span class="keyword">continue</span> recursion&gt; = <span class="number">233</span></div><div class="line">    &lt;Choose split axis position <span class="keyword">for</span> interior node <span class="number">236</span>&gt;</div><div class="line">    &lt;Create leaf <span class="keyword">if</span> no good splits were found <span class="number">239</span>&gt;</div><div class="line">    &lt;Classify primitives with respect to split <span class="number">239</span>&gt;</div><div class="line">    &lt;Recursively initialize children nodes <span class="number">240</span>&gt;</div></pre></td></tr></table></figure></p>
<p>此处选择分割平面的依据是同BVH的SAH。这里估算出一系列候选分裂面的成本，并选择出成本最小的平面作为实际操作的分裂面。在KD树中，钦定求交花费$t<em>{isect}$为80，遍历花费$t</em>{trav}$为1。实际上，这两者的比率决定了算法的运行结果，可以看到，相比于BVH，KD树对结点的访问更廉价。最后一点，KD树倾向于选择那些能够使其中一个子结点没有图元的分割，因为光线可以立即跳过这个子结点转向下一个结点，而不做任何求交运算。这样，对于未分割的区域和分割的区域，它们的成本分别如下。其中：be是一个奖励值（Bonus Value），如果两个子区域非空它的值是0，否则它是处于0到1之间的值；两个概率值p由几何概型求得。<br>$$t<em>{isect}N\<br>t</em>{trav}+(1-b_e)(p_BN<em>Bt</em>{isect}+p_AN<em>At</em>{isect})$$<br>得到花费模型后，下一步解决如何生成分割候选位置并对于每个候选位置如何有效地计算其成本。可以看出这个模型的最小成本所对应的分割位置，应是和某个图元的包围盒的某一面是重合的，所以不应在中间位置上分割。在这里，要考虑区域中所有包围盒的面对一个或多个坐标轴所产生的分割位置。<br>为计算每个候选的成本，要扫描所有包围盒到每个轴上的投影并记录下成本最小的那个位置。每个包围盒在每个坐标轴上的投影是两条垂直于轴的边，它们都用BoundEdge结构的实例表示。这个结构记录了边在轴上的位置，并标明它是始边还是尾边以及它所关联的图元。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;KdTreeAccel Local Declarations&gt; +≡</div><div class="line">    <span class="keyword">struct</span> BoundEdge</div><div class="line">    &#123;</div><div class="line">        &lt;BoundEdge Public Methods <span class="number">235</span>&gt;</div><div class="line">        <span class="keyword">float</span> t;</div><div class="line">        <span class="keyword">int</span> primNum;</div><div class="line">        <span class="keyword">enum</span> &#123; START, END &#125; type;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&lt;BoundEdge Public Methods&gt; ≡ <span class="number">235</span></div><div class="line">    BoundEdge(<span class="keyword">float</span> tt, <span class="keyword">int</span> pn, <span class="keyword">bool</span> starting)</div><div class="line">    &#123;</div><div class="line">        t = tt;</div><div class="line">        primNum = pn;</div><div class="line">        type = starting ? START : END;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>为了计算任何结点上的成本，最多需要2 * prims.size()个BoundEdge。所有这些边的内存一次性全部申请，然后可以被新创建的结点再利用。内存释放片段略。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Allocate working memory <span class="keyword">for</span> kd-tree construction&gt; ≡ <span class="number">232</span></div><div class="line">    BoundEdge *edges[<span class="number">3</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        edges[i] = <span class="keyword">new</span> BoundEdge[<span class="number">2</span>*primitives.size()];</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>计算出将该结点作为叶结点的成本后，buildTree()选择一个分割轴并计算每个候选分割位置的成本。bestAxis和bestOffset分别记录目前已经找到的最佳轴和最佳分割位置。invTotalSA被初始化为结点表面积的倒数，它的值要用于计算光线穿过候选子结点的概率。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;Choose split axis position <span class="keyword">for</span> interior node&gt; ≡ <span class="number">234</span></div><div class="line">    <span class="keyword">int</span> bestAxis = <span class="number">-1</span>, bestOffset = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">float</span> bestCost = INFINITY;</div><div class="line">    <span class="keyword">float</span> oldCost = isectCost * <span class="keyword">float</span>(nPrimitives);</div><div class="line">    <span class="keyword">float</span> totalSA = nodeBounds.SurfaceArea();</div><div class="line">    <span class="keyword">float</span> invTotalSA = <span class="number">1.f</span> / totalSA;</div><div class="line">    Vector d = nodeBounds.pMax - nodeBounds.pMin;</div><div class="line">    &lt;Choose which axis to split along <span class="number">236</span>&gt;</div><div class="line">    <span class="keyword">int</span> retries = <span class="number">0</span>;</div><div class="line">    retrySplit:</div><div class="line">    &lt;Initialize edges <span class="keyword">for</span> axis <span class="number">236</span>&gt;</div><div class="line">    &lt;Compute cost of all splits <span class="keyword">for</span> axis to find best <span class="number">237</span>&gt;</div></pre></td></tr></table></figure></p>
<p>这个函数首先试选择空间幅度最大的轴，如果在这个轴上不能找到好的分割，还要继续选择其它轴。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Choose which axis to split along&gt; ≡ <span class="number">236</span></div><div class="line">    <span class="keyword">uint32_t</span> axis = nodeBounds.MaximumExtent();</div></pre></td></tr></table></figure></p>
<p>首先，用所有和结点重叠的图元的包围盒来初始化关于该轴的BoundEdge数组。之后数组沿坐标轴由低到高排序。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;Initialize edges <span class="keyword">for</span> axis&gt; ≡ <span class="number">236</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nPrimitives; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> pn = primNums[i];</div><div class="line">        <span class="keyword">const</span> BBox &amp;bbox = allPrimBounds[pn];</div><div class="line">        edges[axis][<span class="number">2</span>*i] = BoundEdge(bbox.pMin[axis], pn, <span class="literal">true</span>);</div><div class="line">        edges[axis][<span class="number">2</span>*i+<span class="number">1</span>] = BoundEdge(bbox.pMax[axis], pn, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">    sort(&amp;edges[axis][<span class="number">0</span>], &amp;edges[axis][<span class="number">2</span>*nPrimitives]);</div></pre></td></tr></table></figure></p>
<p>C++标准排序sort()需要结构体按顺序排列，BoundEdge::t完成比较工作。如果t值相同，则比较结点类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;BoundEdge Public Methods&gt; +≡ <span class="number">235</span></div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> BoundEdge &amp;e) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (t == e.t)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)type &lt; (<span class="keyword">int</span>)e.type;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> t &lt; e.t;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>边的数组完成排序后，计算每个位置分割的花费。利用子结点的表面积计算光线穿过每个子结点概率，用变量nBelow和nAbove记录分割区域两侧的图元数目并在每次循环中及时更新，保持nBelow的值是在分割平面之下的图元数而nAbove的值是分割平面之上的图元数。对于第一条边，所有图元都在该边之上，所以nAbove=nPrims，nBelow=0。每当循环体考虑在一个包围盒的尾部进行分割时，–nAbove，因为该包围盒已在分割面之下。类似，当计算完分割成本后，如果分割位置在包围盒范围的起始位置，那么这个包围盒就会在所有后继分割平面之下。所以，在循环的开始和结束要更新这两个变量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;Compute cost of all splits <span class="keyword">for</span> axis to find best&gt; ≡ <span class="number">236</span></div><div class="line">    <span class="keyword">int</span> nBelow = <span class="number">0</span>, nAbove = nPrimitives;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*nPrimitives; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (edges[axis][i].type == BoundEdge::END)</div><div class="line">        &#123;</div><div class="line">            --nAbove;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">float</span> edget = edges[axis][i].t;</div><div class="line">        <span class="keyword">if</span> (edget &gt; nodeBounds.pMin[axis] &amp;&amp;</div><div class="line">            edget &lt; nodeBounds.pMax[axis])</div><div class="line">        &#123;</div><div class="line">            &lt;Compute cost <span class="keyword">for</span> split at ith edge <span class="number">238</span>&gt;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (edges[axis][i].type == BoundEdge::START)</div><div class="line">        &#123;</div><div class="line">            ++nBelow;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>计算出一个分割所对应的成本。belowSA和aboveSA是两个候选子包围盒的表面积。给定一个轴的编号，我们可以利用数组otherAxis来快速地找出其它两个轴的编号而无需使用条件语句。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;Compute cost <span class="keyword">for</span> split at ith edge&gt; ≡ <span class="number">237</span></div><div class="line">    <span class="keyword">uint32_t</span> otherAxis0 = (axis + <span class="number">1</span>) % <span class="number">3</span>, otherAxis1 = (axis + <span class="number">2</span>) % <span class="number">3</span>;</div><div class="line">    <span class="keyword">float</span> belowSA = <span class="number">2</span> * (d[otherAxis0] * d[otherAxis1] +</div><div class="line">                        (edget - nodeBounds.pMin[axis]) *</div><div class="line">                        (d[otherAxis0] + d[otherAxis1]));</div><div class="line">    <span class="keyword">float</span> aboveSA = <span class="number">2</span> * (d[otherAxis0] * d[otherAxis1] +</div><div class="line">                        (nodeBounds.pMax[axis] - edget) *</div><div class="line">                        (d[otherAxis0] + d[otherAxis1]));</div><div class="line">    <span class="keyword">float</span> pBelow = belowSA * invTotalSA;</div><div class="line">    <span class="keyword">float</span> pAbove = aboveSA * invTotalSA;</div><div class="line">    <span class="keyword">float</span> eb = (nAbove == <span class="number">0</span> || nBelow == <span class="number">0</span>) ? emptyBonus : <span class="number">0.f</span>;</div><div class="line">    <span class="keyword">float</span> cost = traversalCost +</div><div class="line">                 isectCost * (<span class="number">1.f</span> - eb) * (pBelow * nBelow + pAbove * nAbove);</div><div class="line">    &lt;Update best split <span class="keyword">if</span> <span class="keyword">this</span> is lowest cost so far <span class="number">238</span>&gt;</div></pre></td></tr></table></figure></p>
<p>如果计算出的成本是当前最低，则记录下分割细节。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Update best split <span class="keyword">if</span> <span class="keyword">this</span> is lowest cost so far&gt; ≡ <span class="number">238</span></div><div class="line">    <span class="keyword">if</span> (cost &lt; bestCost)</div><div class="line">    &#123;</div><div class="line">        bestCost = cost;</div><div class="line">        bestAxis = axis;</div><div class="line">        bestOffset = i;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在前面的测试中，也有可能找不到分割点（如多个包围盒都包围同一个树结点，没有令两个子区域含有更少图元的分割位置）。此时要尝试换用其它两个轴，如果所有的轴都试过仍然没有找到分割位置，只好放弃，将其放入叶结点中。另外，也有可能出现最有分割所对应的成本仍高于不分割时的成本。如果这个分割显著恶化了效率且没有太多的图元，就立刻创建叶结点。否则，利用badRefines变量来记录当前错误分割的次数。系统容许错误分割的出现，因为其后有可能出现不错的分割。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;Create leaf <span class="keyword">if</span> no good splits were found&gt; ≡ <span class="number">234</span></div><div class="line">    <span class="keyword">if</span> (bestAxis == <span class="number">-1</span> &amp;&amp; retries &lt; <span class="number">2</span>)</div><div class="line">    &#123;</div><div class="line">        ++retries;</div><div class="line">        axis = (axis+<span class="number">1</span>) % <span class="number">3</span>;</div><div class="line">        <span class="keyword">goto</span> retrySplit;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (bestCost &gt; oldCost) </div><div class="line">    &#123;</div><div class="line">        ++badRefines;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((bestCost &gt; <span class="number">4.f</span> * oldCost &amp;&amp; nPrimitives &lt; <span class="number">16</span>) ||</div><div class="line">         bestAxis == <span class="number">-1</span> || badRefines == <span class="number">3</span>)</div><div class="line">    &#123;</div><div class="line">        nodes[nodeNum].initLeaf(primNums, nPrimitives, arena);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>得到最佳分割位置，之后用包围盒边确定图元是在分割平面之上，之下，或both。其方法跟前面记录nBelow和nAbove的方法类似。注意跳过下标为bestOffset的数组，这是为避免图元同时被分类到两个子结点中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;Classify primitives with respect to split&gt; ≡ <span class="number">234</span></div><div class="line">    <span class="keyword">int</span> n0 = <span class="number">0</span>, n1 = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bestOffset; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (edges[bestAxis][i].type == BoundEdge::START)</div><div class="line">        &#123;</div><div class="line">            prims0[n0++] = edges[bestAxis][i].primNum;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = bestOffset+<span class="number">1</span>; i &lt; <span class="number">2</span>*nPrimitives; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (edges[bestAxis][i].type == BoundEdge::END)</div><div class="line">        &#123;</div><div class="line">            prims1[n1++] = edges[bestAxis][i].primNum;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>回忆一下：在KD树结点数组中，当前结点的下面的子结点是当前结点编号加1。这个子结点的递归结束后，nextFreeNode偏移量就要为上面的子结点所用。另一个细节，prims0的内存可以直接传给两个子结点并再被利用，而prims1指针要向后移动nPrimitives个位置才可以传给两个子结点。这是因为当前调用的buildTree()所依赖的prims1值被储存于上个递归的buildTree()中，因此必须作为参数传递给第二个递归。然而，没有必要保留edges和prims0。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;Recursively initialize children nodes&gt; ≡ <span class="number">234</span></div><div class="line">    <span class="keyword">float</span> tsplit = edges[bestAxis][bestOffset].t;</div><div class="line">    BBox bounds0 = nodeBounds, bounds1 = nodeBounds;</div><div class="line">    bounds0.pMax[bestAxis] = bounds1.pMin[bestAxis] = tsplit;</div><div class="line">    buildTree(nodeNum+<span class="number">1</span>, bounds0,</div><div class="line">              allPrimBounds, prims0, n0, depth<span class="number">-1</span>, edges,</div><div class="line">              prims0, prims1 + nPrimitives, badRefines);</div><div class="line">    <span class="keyword">uint32_t</span> aboveChild = nextFreeNode;</div><div class="line">    nodes[nodeNum].initInterior(bestAxis, aboveChild, tsplit);</div><div class="line">    buildTree(aboveChild, bounds1, allPrimBounds, prims1, n1,</div><div class="line">              depth<span class="number">-1</span>, edges, prims0, prims1 + nPrimitives, badRefines);</div></pre></td></tr></table></figure></p>
<p>为了应对最坏情况，prims1所需内存比prims0要大得多。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Allocate working memory <span class="keyword">for</span> kd-tree construction&gt; +≡ <span class="number">232</span></div><div class="line">    <span class="keyword">uint32_t</span> *prims0 = <span class="keyword">new</span> <span class="keyword">uint32_t</span>[primitives.size()];</div><div class="line">    <span class="keyword">uint32_t</span> *prims1 = <span class="keyword">new</span> <span class="keyword">uint32_t</span>[(maxDepth+<span class="number">1</span>) * primitives.size()];</div></pre></td></tr></table></figure></p>
<h3 id="4-5-3-遍历"><a href="#4-5-3-遍历" class="headerlink" title="4.5.3 遍历"></a>4.5.3 遍历</h3><p>首先，tmin和tmax被初始化为光线跟树的包围盒两个交点的参数距离。同网格加速器，如果光线和场景的包围盒没有交点，立即返回false。否则，就要从树的根结点开始，遍历这个树。在每个内部结点，算法确定光线先进入两个子结点的哪一个，并安装先后顺序遍历子结点。当光线走出树，或者找到了最近交点，结束。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;KdTreeAccel Method Definitions&gt; +≡</div><div class="line">    <span class="keyword">bool</span> KdTreeAccel::Intersect(<span class="keyword">const</span> Ray &amp;ray,</div><div class="line">                                Intersection *isect) <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        &lt;Compute initial parametric range of ray inside kd-tree extent <span class="number">240</span>&gt;</div><div class="line">        &lt;Prepare to traverse kd-tree <span class="keyword">for</span> ray <span class="number">241</span>&gt;</div><div class="line">        &lt;Traverse kd-tree nodes in order <span class="keyword">for</span> ray <span class="number">242</span>&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先寻找光线和包围盒相交的参数范围[tmin, tmax]，如果没有交点则立即退出。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Compute initial parametric range of ray inside kd-tree extent&gt; ≡ <span class="number">240</span></div><div class="line">    <span class="keyword">float</span> tmin, tmax;</div><div class="line">    <span class="keyword">if</span> (!bounds.IntersectP(ray, &amp;tmin, &amp;tmax))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>KdToDo数组用来存放还没有处理的结点，它的最后一项应是下一个要考虑的结点。数组的大小是KD树的最大深度。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;Prepare to traverse kd-tree <span class="keyword">for</span> ray&gt; ≡ <span class="number">240</span></div><div class="line">    <span class="function">Vector <span class="title">invDir</span><span class="params">(<span class="number">1.f</span>/ray.d.x, <span class="number">1.f</span>/ray.d.y, <span class="number">1.f</span>/ray.d.z)</span></span>;</div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_TODO 64</span></div><div class="line">    KdToDo todo[MAX_TODO];</div><div class="line">    <span class="keyword">int</span> todoPos = <span class="number">0</span>;</div><div class="line"></div><div class="line">&lt;KdTreeAccel Declarations&gt; +≡</div><div class="line">    <span class="keyword">struct</span> KdToDo</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">const</span> KdAccelNode *node;</div><div class="line">        <span class="keyword">float</span> tmin, tmax;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>遍历过程对nodes数组进行循环，每次循环处理一个叶子结点或内部结点。tmin和tmax随即更新。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;Traverse kd-tree nodes in order <span class="keyword">for</span> ray&gt; ≡ <span class="number">240</span></div><div class="line">    <span class="keyword">bool</span> hit = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">const</span> KdAccelNode *node = &amp;nodes[<span class="number">0</span>];</div><div class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        &lt;Bail out <span class="keyword">if</span> we found a hit closer than the current node <span class="number">242</span>&gt;</div><div class="line">        <span class="keyword">if</span> (!node-&gt;IsLeaf())</div><div class="line">        &#123;</div><div class="line">            &lt;Process kd-tree interior node <span class="number">242</span>&gt;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">        &#123;</div><div class="line">            &lt;Check <span class="keyword">for</span> intersections inside leaf node <span class="number">244</span>&gt;</div><div class="line">            &lt;Grab next node to process from todo <span class="built_in">list</span> <span class="number">245</span>&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hit;</div></pre></td></tr></table></figure></p>
<p>有可能存在这样的情况，在之前的求交中找到了横跨多个结点的图元与光线的交点。如果第一次发现这样的交点时，交点位置在当前的结点之外，那么必须继续遍历树，直到找到一个tmin比交点还要远的结点。只有这时，才能确定在其他图元中没有比这个交点更近的点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Bail out <span class="keyword">if</span> we found a hit closer than the current node&gt; ≡ <span class="number">242</span></div><div class="line">    <span class="keyword">if</span> (ray.maxt &lt; tmin)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对于内部结点，求光线和分割平面的交点，并确定是否处理其中一个结点，还是两个结点都要处理，并且确定处理两个子结点的先后次序。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Process kd-tree interior node&gt; ≡ <span class="number">242</span></div><div class="line">    &lt;Compute parametric distance along ray to split plane <span class="number">242</span>&gt;</div><div class="line">    &lt;Get node children pointers <span class="keyword">for</span> ray <span class="number">243</span>&gt;</div><div class="line">    &lt;Advance to next child node, possibly enqueue other child <span class="number">244</span>&gt;</div></pre></td></tr></table></figure></p>
<p>光线和分割平面的求交方法跟光线和包围盒交点的求法类似。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Compute parametric distance along ray to split plane&gt; ≡ <span class="number">242</span></div><div class="line">    <span class="keyword">int</span> axis = node-&gt;SplitAxis();</div><div class="line">    <span class="keyword">float</span> tplane = (node-&gt;SplitPos() - ray.o[axis]) * invDir[axis];</div></pre></td></tr></table></figure></p>
<p>现在确定光线进入子结点的次序，使得树的遍历是沿着光线从前向后的顺序进行的。只需比较光线原点和分割面位置，就可以确定先后次序。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;Get node children pointers <span class="keyword">for</span> ray&gt; ≡ <span class="number">242</span></div><div class="line">    <span class="keyword">const</span> KdAccelNode *firstChild, *secondChild;</div><div class="line">    <span class="keyword">int</span> belowFirst = (ray.o[axis] &lt; node-&gt;SplitPos()) ||</div><div class="line">                     (ray.o[axis] == node-&gt;SplitPos() &amp;&amp; ray.d[axis] &gt;= <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (belowFirst)</div><div class="line">    &#123;</div><div class="line">        firstChild = node + <span class="number">1</span>;</div><div class="line">        secondChild = &amp;nodes[node-&gt;AboveChild()];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> </div><div class="line">    &#123;</div><div class="line">        firstChild = &amp;nodes[node-&gt;AboveChild()];</div><div class="line">        secondChild = node + <span class="number">1</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>有时候没有必要对两个子结点都进行处理：有时光线只穿过其中一个子结点。下述第一个条件语句表示如果光线背对远结点或者并不穿过远结点，那么只处理近结点。第二个条件语句表示如果光线不穿过近结点就不必处理它。最后表示先处理近结点并把远结点放入todo数组中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;Advance to next child node, possibly enqueue other child&gt; ≡ <span class="number">242</span></div><div class="line">    <span class="keyword">if</span> (tplane &gt; tmax || tplane &lt;= <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        node = firstChild;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tplane &lt; tmin)</div><div class="line">    &#123;</div><div class="line">        node = secondChild;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        &lt;Enqueue secondChild in todo <span class="built_in">list</span> <span class="number">244</span>&gt;</div><div class="line">        node = firstChild;</div><div class="line">        tmax = tplane;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&lt;Enqueue secondChild in todo <span class="built_in">list</span>&gt; ≡ <span class="number">244</span></div><div class="line">    todo[todoPos].node = secondChild;</div><div class="line">    todo[todoPos].tmin = tplane;</div><div class="line">    todo[todoPos].tmax = tmax;</div><div class="line">    ++todoPos;</div></pre></td></tr></table></figure></p>
<p>如果当前结点是叶结点，对其中图元求交。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;Check <span class="keyword">for</span> intersections inside leaf node&gt; ≡ <span class="number">242</span></div><div class="line">    <span class="keyword">uint32_t</span> nPrimitives = node-&gt;nPrimitives();</div><div class="line">    <span class="keyword">if</span> (nPrimitives == <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">const</span> Reference&lt;Primitive&gt; &amp;prim = primitives[node-&gt;onePrimitive];</div><div class="line">        &lt;Check one primitive inside leaf node <span class="number">244</span>&gt;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">uint32_t</span> *prims = node-&gt;primitives;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; nPrimitives; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">const</span> Reference&lt;Primitive&gt; &amp;prim = primitives[prims[i]];</div><div class="line">            &lt;Check one primitive inside leaf node <span class="number">244</span>&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对单个图元，只需调用图元的求交函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Check one primitive inside leaf node&gt; ≡ <span class="number">244</span></div><div class="line">    <span class="keyword">if</span> (prim-&gt;Intersect(ray, isect))</div><div class="line">    hit = <span class="literal">true</span>;</div></pre></td></tr></table></figure></p>
<p>叶结点上求求交完成后，从todo数组中得到下一结点。如果数组为空，表示光线就穿过了整个树且没有留下交点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;Grab next node to process from todo <span class="built_in">list</span>&gt; ≡ <span class="number">242</span></div><div class="line">    <span class="keyword">if</span> (todoPos &gt; <span class="number">0</span>) </div><div class="line">    &#123;</div><div class="line">        --todoPos;</div><div class="line">        node = todo[todoPos].node;</div><div class="line">        tmin = todo[todoPos].tmin;</div><div class="line">        tmax = todo[todoPos].tmax;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>同GridAccel，KdTreeAccelI也拥有只发现交点而并不寻找最近交点的函数IntersectP()，不再赘述。</p>
<h2 id="4-6-聚合体的查错-P274"><a href="#4-6-聚合体的查错-P274" class="headerlink" title="4.6 聚合体的查错 P274"></a>4.6 聚合体的查错 P274</h2><p>聚合体（Aggregates）中的错误往往难以调试，它的错误往往体现在极其细微的部分并且常常导致加速结构的崩溃。本章讨论一些高效的查错技巧和有用的测试方式。<br>首先，需要明白什么是求交计算的正确结果：只要光与包围盒相交，就能得到符合光线参数范围的和某图元相交的最近的交点值。注意：可能会出现多个图元返回相同的交点值t的情况。在这种情况下，可以认为光相交与其中任意的图元，并且此时一般不值得引入更苛刻的条件对这些图元进行筛选。第二个细节是由于浮点数误差的问题，可能存在一些光线，包围盒求交函数认为光线不与其相交，但图元求交函数认为光线与其相交。对于这种交点，加速结构没有义务将它们计算出来：也就是说，若是没能计算出些点，不被认为是错误结果；若是侥幸计算出这些点，也不被认为是错误。<br>定义了求交计算的正确结果，意味着采用不同的加速结构得到的图形可能存在细微的区别。为此，对比两个具有细微区别的渲染结果并对加速结构进行逆向查错是一种有效的debug方式，尽管有些笨重。</p>
<h3 id="4-6-1-在聚合体中发现错误"><a href="#4-6-1-在聚合体中发现错误" class="headerlink" title="4.6.1 在聚合体中发现错误"></a>4.6.1 在聚合体中发现错误</h3><p>PBRT为测试聚合体提供了AggregateTest Renderer。对于给定的场景，在场景中生成大量随机光线。第一次采用场景描述文件中钦定的加速结构进行加速，第二次对场景中每个图元进行求交测试。如果二者结果不一致（前提是必须保证光线求交的计算方式正确），那么加速结构必定有问题。那些光线的信息也将被打印以便于后续的调试工作。renderers/aggregatetest.h和renderers/aggregatetest.cpp收录了AggregateTest。<br>普遍的讲，在这种直接测试中寻找和测试错误往往比得到一个吓人的渲染结果之后再debug更容易一些。而只追踪一条光线的调试方式往往不会得到正确的渲染结果且会使调试过程变得狭隘，而自动测试则能发现更多隐藏的问题。另一个建议，当修改系统本身后，最好执行测试以确保之前做出的修改不会引出潜在的错误。<br>AggregateTest的构造函数这里不再赘述，它需要图元、包围盒和光线。测试始于AggregateTest::Render()。首先，计算出一个比整个场景略大的包围盒，之后在给定的次数内反复迭代，包围盒内生成随机光线，计算交点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;AggregateTest Method Definitions&gt; ≡</div><div class="line">    <span class="keyword">void</span> AggregateTest::Render(<span class="keyword">const</span> Scene *scene)</div><div class="line">    &#123;</div><div class="line">        RNG rng;</div><div class="line">        &lt;Compute bounding box of region used to generate random rays <span class="number">247</span>&gt;</div><div class="line">        Point lastHit;</div><div class="line">        <span class="keyword">float</span> lastEps = <span class="number">0.f</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nIterations; ++i)</div><div class="line">        &#123;</div><div class="line">            &lt;Choose random rays, rayAccel and rayAll <span class="keyword">for</span> testing <span class="number">247</span>&gt;</div><div class="line">            &lt;Compute intersections <span class="keyword">using</span> accelerator and exhaustive testing <span class="number">248</span>&gt;</div><div class="line">            &lt;Report any inconsistencies between intersections <span class="number">249</span>&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;Compute bounding box of region used to generate random rays&gt; ≡ <span class="number">247</span></div><div class="line">    BBox bbox = scene-&gt;WorldBound();</div><div class="line">    bbox.Expand(bbox.pMax[bbox.MaximumExtent()] -</div><div class="line">    bbox.pMin[bbox.MaximumExtent()]);</div></pre></td></tr></table></figure></p>
<p>光线的生成过程要高效，还要足够典型，以至于能暴露出加速结构中的问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Choose random rays, rayAccel and rayAll <span class="keyword">for</span> testing&gt; ≡ <span class="number">247</span></div><div class="line">    &lt;Choose ray origin <span class="keyword">for</span> testing accelerator <span class="number">248</span>&gt;</div><div class="line">    &lt;Choose ray direction <span class="keyword">for</span> testing accelerator <span class="number">248</span>&gt;</div><div class="line">    &lt;Choose ray epsilon <span class="keyword">for</span> testing accelerator <span class="number">248</span>&gt;</div><div class="line">    <span class="function">Ray <span class="title">rayAccel</span><span class="params">(org, dir, eps)</span></span>;</div><div class="line">    Ray rayAll = rayAccel;</div></pre></td></tr></table></figure></p>
<p>光线原点有两种选择方式：其一，场景包围盒内随机点；其二，由之前的光线和面的交点确定。此外，光线最好始于场景平面（Scene Surfaces）或是始于其附近，原因有二：其一，在渲染过程中大部分的光线会远离交点平面；其二，这种情况下的出现的错误往往是难以发现的。如果那些始于相机位置的光线出现错误，那么这种错误往往会得到吓人的渲染结果；相反，若光线在表面上的反射得到错误的交点数据，这时的错误直观看起来并不明显。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Choose ray origin for testing accelerator&gt; ≡ 247</div><div class="line">    Point org(Lerp(rng.RandomFloat(), bbox.pMin.x, bbox.pMax.x),</div><div class="line">              Lerp(rng.RandomFloat(), bbox.pMin.y, bbox.pMax.y),</div><div class="line">              Lerp(rng.RandomFloat(), bbox.pMin.z, bbox.pMax.z));</div><div class="line">    if ((rng.RandomUInt() % 4) == 0)</div><div class="line">    &#123;</div><div class="line">        org = lastHit;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>光线的方向往往随机选择一个方向。然，偶尔设置两个分量为零是很不错的技巧：平行与坐标轴的光有时会带来意外之喜（大雾）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;Choose ray direction <span class="keyword">for</span> testing accelerator&gt; ≡ <span class="number">247</span></div><div class="line">    Vector dir = UniformSampleSphere(rng.RandomFloat(), rng.RandomFloat());</div><div class="line">    <span class="keyword">if</span> ((rng.RandomUInt() % <span class="number">32</span>) == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        dir.x = dir.y = <span class="number">0.f</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((rng.RandomUInt() % <span class="number">32</span>) == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        dir.x = dir.z = <span class="number">0.f</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((rng.RandomUInt() % <span class="number">32</span>) == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        dir.y = dir.z = <span class="number">0.f</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>最后，钦定光线的E值，即交点被忽略的最小参数距离。这一步也要求随机：E值会在零、上一个表面交点的E值、极小浮点值之间三选一。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;Choose ray epsilon <span class="keyword">for</span> testing accelerator&gt; ≡ <span class="number">247</span></div><div class="line">    <span class="keyword">float</span> eps = <span class="number">0.f</span>;</div><div class="line">    <span class="keyword">if</span> (rng.RandomFloat() &lt; <span class="number">.25</span>) </div><div class="line">    &#123;</div><div class="line">        eps = lastEps;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rng.RandomFloat() &lt; <span class="number">.25</span>)</div><div class="line">    &#123;</div><div class="line">        eps = <span class="number">1e-3</span>f;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>到这一步，AggregateTest使用加速结构和穷举图元两种方式进行交点计算。注意，设置inconsistentBounds来处理光线没有命中包围盒但仍击中几何体这种情况，这种前后相悖的交点不会被报道。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;Compute intersections <span class="keyword">using</span> accelerator and exhaustive testing&gt; ≡ <span class="number">247</span></div><div class="line">    Intersection isectAccel, isectAll;</div><div class="line">    <span class="keyword">bool</span> hitAccel = scene-&gt;Intersect(rayAccel, &amp;isectAccel);</div><div class="line">    <span class="keyword">bool</span> hitAll = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">bool</span> inconsistentBounds = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; primitives.size(); ++j)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (bboxes[j].IntersectP(rayAll))</div><div class="line">        &#123;</div><div class="line">            hitAll |= primitives[j]-&gt;Intersect(rayAll, &amp;isectAll);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (primitives[j]-&gt;Intersect(rayAll, &amp;isectAll))</div><div class="line">        &#123;</div><div class="line">            inconsistentBounds = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先排除掉前后相悖的交点，若加速结构和穷举图元两种方式依旧得到不同的参数t值，打印Warning，包括了光线的原点和方向，此外采用%a的形式以16进制精确输出。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Report any inconsistencies between intersections&gt; ≡ <span class="number">247</span></div><div class="line">    <span class="keyword">if</span> (!inconsistentBounds &amp;&amp;</div><div class="line">        ((hitAccel != hitAll) || (rayAccel.maxt != rayAll.maxt)))</div><div class="line">    &#123;</div><div class="line">        Warning(<span class="string">"Disagreement: t accel %.16g [%a] t exhaustive %.16g [%a]\n"</span></div><div class="line">                <span class="string">"Ray: org [%a, %a, %a], dir [%a, %a, %a], mint = %a"</span>,</div><div class="line">                rayAccel.maxt, rayAll.maxt, rayAccel.maxt, rayAll.maxt,</div><div class="line">                rayAll.o.x, rayAll.o.y, rayAll.o.z,</div><div class="line">                rayAll.d.x, rayAll.d.y, rayAll.d.z, rayAll.mint);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (hitAll) </div><div class="line">    &#123;</div><div class="line">        lastHit = rayAll(rayAll.maxt);</div><div class="line">        lastEps = isectAll.rayEpsilon;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-6-2-在聚合体中修复错误"><a href="#4-6-2-在聚合体中修复错误" class="headerlink" title="4.6.2 在聚合体中修复错误"></a>4.6.2 在聚合体中修复错误</h3><p>修复bug的第一步，是找到正确情况下光线应该相交的那个最近的图元（Should Have Been），然后思考为什么光线没能够和它相交。对于那些基于空间划分的加速结构，交点位于两个结点的边界上可能会导致问题。错误必须来自以下两个原因之一：其一，遍历过程出现错误，光线没能够穿过交点位于的那个结点；其二，建立加速结构出现问题，含有交点的图元没有被存入结点中。对于那些基于图元划分的加速结构，应该被击中的图元会存在于一个或多个结点中，思考为何光线没能访问那些结点，或是如果访问了，为何没能得到交点数据。<br>此外的一个建议是打印出追踪前后相关的数据信息以便寻找出源码中的问题。</p>
<h3 id="4-6-3-聚合体性能错误"><a href="#4-6-3-聚合体性能错误" class="headerlink" title="4.6.3 聚合体性能错误"></a>4.6.3 聚合体性能错误</h3><p>除了正确性的问题，bug还可能带来性能上的问题——尽管能得到正确的渲染结果，但是却缺乏效率。可以通过大量收集渲染执行的统计数据和采用可视化工具来发现这些问题。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/CG/" rel="tag">#CG</a>
          
            <a href="/tags/PBRT/" rel="tag">#PBRT</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/24/pbrt-ch3/" rel="next" title="PBRT 章节3 形体">
                <i class="fa fa-chevron-left"></i> PBRT 章节3 形体
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/04/pbrt-ch5/" rel="prev" title="PBRT 章节5 颜色与辐射度学">
                PBRT 章节5 颜色与辐射度学 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Sulpures" />
          <p class="site-author-name" itemprop="name">Sulpures</p>
          <p class="site-description motion-element" itemprop="description">「今せぇいっぱい生きよう」</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-图元接口与几何图元-P213"><span class="nav-number">1.</span> <span class="nav-text">4.1 图元接口与几何图元 P213</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-几何图元"><span class="nav-number">1.1.</span> <span class="nav-text">4.1.1 几何图元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-物体关联拷贝与动画图元"><span class="nav-number">1.2.</span> <span class="nav-text">4.1.2 物体关联拷贝与动画图元</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-聚合体-P220"><span class="nav-number">2.</span> <span class="nav-text">4.2 聚合体 P220</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-光盒交点"><span class="nav-number">2.1.</span> <span class="nav-text">4.2.1 光盒交点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-网格加速结构-P224"><span class="nav-number">3.</span> <span class="nav-text">4.3 网格加速结构 P224</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-创建"><span class="nav-number">3.1.</span> <span class="nav-text">4.3.1 创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-遍历"><span class="nav-number">3.2.</span> <span class="nav-text">4.3.2 遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-BVH加速结构-P237"><span class="nav-number">4.</span> <span class="nav-text">4.4 BVH加速结构 P237</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-BVH构造"><span class="nav-number">4.1.</span> <span class="nav-text">4.4.1 BVH构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-表面积启发式，"><span class="nav-number">4.2.</span> <span class="nav-text">4.4.2 表面积启发式，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-3-BVH的压缩"><span class="nav-number">4.3.</span> <span class="nav-text">4.4.3 BVH的压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-4-遍历"><span class="nav-number">4.4.</span> <span class="nav-text">4.4.4 遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-KD树加速结构-P256"><span class="nav-number">5.</span> <span class="nav-text">4.5 KD树加速结构 P256</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-树的表示"><span class="nav-number">5.1.</span> <span class="nav-text">4.5.1 树的表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-树的创建"><span class="nav-number">5.2.</span> <span class="nav-text">4.5.2 树的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-3-遍历"><span class="nav-number">5.3.</span> <span class="nav-text">4.5.3 遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-聚合体的查错-P274"><span class="nav-number">6.</span> <span class="nav-text">4.6 聚合体的查错 P274</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-1-在聚合体中发现错误"><span class="nav-number">6.1.</span> <span class="nav-text">4.6.1 在聚合体中发现错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-2-在聚合体中修复错误"><span class="nav-number">6.2.</span> <span class="nav-text">4.6.2 在聚合体中修复错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-3-聚合体性能错误"><span class="nav-number">6.3.</span> <span class="nav-text">4.6.3 聚合体性能错误</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sulpures</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  

</body>
</html>
